<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>Collate Interface</title>
<script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
<script type="text/javascript">
  
  var userName = "{{ userName }}";
  var urn = "{{ urn }}";
  var ruleSetName = "{{ ruleSetName }}";
  var witnessDataTokens = (("{{ witnessesTokens}}")).replace(/&(l|g|quo)t;/g, function(a,b)
  {
    return {
      l : '<',
      g : '>',
      quo : '"'
    }[b];
  });
  var witnessDataLines = (("{{ witnessesLines}}")).replace(/&(l|g|quo)t;/g, function(a,b)
  {
    return {
      l : '<',
      g : '>',
      quo : '"'
    }[b];
  });
  var ruleSet = (("{{ ruleSet }}")).replace(/&(l|g|quo)t;/g, function(a,b)
  {
    return {
      l : '<',
      g : '>',
      quo : '"'
    }[b];
  });

var allWitnesses;
var newRules;
var contextStruct;
var allTokens;
var totalPos;
var currentPosition = "{{ position }}";
var regOn;
var iTimeoutId = null;
var allRules;
var reg_thisBox;
var reg_toBox;
var origTokens;
var isBuildWitnesses;
var isRecollate;
var customRules;
var isCustomRules;
var autoReg;
var distinct;
var changeLabelTimer = null;
var isOriginals;
var isRealign;

function load()
{
  witnessDataTokens = witnessDataTokens.replace(/u'/g, '\'');
  witnessDataTokens = witnessDataTokens.replace(/'/g, '\"');
  witnessDataTokens = JSON.parse(witnessDataTokens);

  witnessDataLines = witnessDataLines.replace(/u'/g, '\'');
  witnessDataLines = witnessDataLines.replace(/'/g, '\"');
  witnessDataLines = JSON.parse(witnessDataLines);
  
  ruleSet = ruleSet.replace(/u'/g, '\'');
  ruleSet = ruleSet.replace(/'/g, '\"');
  ruleSet = JSON.parse(ruleSet);
  
  var temp = urn.split("entity=")[1];
  var entity = temp.split(":", 1)[0];
  var line = temp.split("Line=")[1];
  document.getElementById("title_label").innerHTML = "entity " + entity + ", line " + line;
  
  document.information.style.visibility = "hidden";
  document.reg_information.style.visibility ="hidden";
  document.edit_reg.style.visibility = "hidden";
  document.regularization.reg_checkbox.checked = true;
  showRegularization(document.regularization.reg_checkbox);
  
  isOriginals = false;
  isRealign = false;
  newRules = { rules: [] };
  customRules = { rules: [] };
  allRules = { rules: [] };
  for(var i in ruleSet.ruleSet.rules)
  {
    allRules.rules.push(ruleSet.ruleSet.rules[i]);
  }
  contextStruct = { witnesses: [] };

  regOn = false;
  
  isBuildWitnesses = false;
  isRecollate = false;
  isCustomRules = false;
  autoReg = false;
  distinct = { witnesses: [] };
  
   // add keyboard shortcut
  shortcut.add("Alt+Right", function () {
    addTokenThis();
  });

  shortcut.add("Shift+Right", function () {
    addTokenTo();
  });

  shortcut.add("Tab", function() {
    findNextVariant();
  });
  
  shortcut.add("Enter", function() {
      addRule();
    });
    
  allTokens = witnessDataTokens;
  origTokens = witnessDataTokens;
  allWitnesses = witnessDataLines;
  
  totalPos = allTokens.alignment[0].tokens.length;
  
  regularize(newRules);
}

function nextToken()
{
  var reg_toWhole = document.regularization.reg_to.value;
  document.regularization.reg_this.value = "";
  //document.regularization.reg_to.value = "";

  if(currentPosition == totalPos)
  {
    if(regOn)
    {
      if(isRecollate)
      {
        recollate();
        isRecollate = false;
      }
      
      if(isCustomRules)
      {
        var regRules = customRules;
      }
      else
      {
        var regRules = allRules;
      }
      
      for(var i in newRules.rules)
      {
        regRules.rules.push(newRules.rules[i]);
      }
      regularize(regRules);
    }
    else
    {
      allTokens = origTokens;
      regularize(newRules);
    }
  }
  else
  {
    if(regOn)
    {
      if(isRecollate)
      {
        recollate();
        isRecollate = false;
      }
      
      if(isCustomRules)
      {
        var regRules = customRules;
      }
      else
      {
        var regRules = allRules;
      }
      
      currentPosition++;
      for(var i in newRules.rules)
      {
        regRules.rules.push(newRules.rules[i]);
      }
      regularize(regRules);
    }
    else
    {
      currentPosition++;
      allTokens = origTokens;
      regularize(newRules);
    }
    
  }
  
  document.regularization.reg_to.value = reg_toWhole;
}

function previousToken()
{
  var reg_toWhole = document.regularization.reg_to.value;
  document.regularization.reg_this.value = "";
  //document.regularization.reg_to.value = "";

  if(currentPosition == 0)
  {
    if(regOn)
    {
      if(isRecollate)
      {
        recollate();
        isRecollate = false;
      }
      
      if(isCustomRules)
      {
        var regRules = customRules;
      }
      else
      {
        var regRules = allRules;
      }
      
      for(var i in newRules.rules)
      {
        regRules.rules.push(newRules.rules[i]);
      }
      regularize(regRules);
    }
    else
    {
      allTokens = origTokens;
      regularize(newRules);
    }
  }
  else
  {
    if(regOn)
    {
      if(isRecollate)
      {
        recollate();
        isRecollate = false;
      }
      
      if(isCustomRules)
      {
        var regRules = customRules;
      }
      else
      {
        var regRules = allRules;
      }
      currentPosition--;
      
      for(var i in newRules.rules)
      {
        regRules.rules.push(newRules.rules[i]);
      }
      regularize(regRules);
    }
    else
    {
      currentPosition--;
      allTokens = origTokens;
      regularize(newRules);
    }
    
  }
  
  document.regularization.reg_to.value = reg_toWhole;
}

function determineClick()
{
  if(!isRealign)
  {
    if (iTimeoutId == null || !iTimeoutId)
    {
      iTimeoutId = setTimeout("selectToken()", 500);
    }
    else
    {
      //window.clearTimeout(iTimeoutId);
      clearTimeout(iTimeoutId);
      iTimeoutId = null;
      selectNew();
    }
  }
  else
  {
    selectRealignToken();
  }
}

function selectRealignToken()
{
  var content = document.regularization.reg.value;
  var txt = document.regularization.reg;
  var pos = txt.selectionStart;

  var token = findWord(pos, content);

  if(!token)
  {
    alert("Invalid selection");
  }
  else if(token != "isId")
  {
    document.realign_token.token.value = token;
  }
}

function findWord(pos, content)
{
  //find whitespaces -- find word indexes
    var found = false;
    var endPos = pos;
    while(!found)
    {
      if(content[endPos] != " ")
      {
        endPos++;
      }
      else
      {
        found = true;
      }
    }

    found = false;
    var startPos = pos;
    while(!found)
    {
      if(content[startPos] != " ")
      {
        if(startPos != 0)
        {
          startPos--;
        }
        else
        {
          found = true;
        }
      }
      else
      {
        found = true;
      }
    }

  var length = endPos - startPos;
  var token = content.substr(startPos, length);
  token = token.split(" ");
  token = token.join("");
  var origToken = token;
  token = token.split("(")[0];

  var notToken = false;
  var isId = false;
  for(var i in allWitnesses.witnesses)
  {
    if(token == allWitnesses.witnesses[i].id)
    {
      informationWindow(allWitnesses.witnesses[i].id);
      isId = true;
      token = "isId";
    }
  }
  
  if(!isId)
  {
    token = origToken;
  }

  if(token == "///" || token == "" || token == "null")
  {
    notToken = true;
  }

  if(notToken)
  {
    return false;
  }
  else
  {
    return token;
  }
}

function selectToken()
{
    window.clearTimeout(iTimeoutId);
    iTimeoutId = null;
    
    var content = document.regularization.reg.value;
    var txt = document.regularization.reg;
    var pos = txt.selectionStart;

    var token = findWord(pos, content);

    if(!token)
    {
      alert("Invalid selection");
    }
    else if(token != "isId")
    {
      document.regularization.reg_this.value = token;
      reg_thisBox = token;
    }

}

function selectNew()
{
  window.clearTimeout(iTimeoutId);
  iTimeoutId = null;
  var content = document.regularization.reg.value;
  var txt = document.regularization.reg;
  var pos = txt.selectionStart;

  token = findWord(pos, content);

  if(!token)
  {
    alert("Invalid selection");
  }
  else if(token != "isId")
  {
    document.regularization.reg_to.value = token;
    reg_toBox = token;
  }
}

function addRule()
{
  var reg_thisWhole = document.regularization.reg_this.value;
  var reg_toWhole = document.regularization.reg_to.value;
    
  if(regOn && reg_thisWhole != reg_toWhole)
  {
    var reg_word = reg_thisBox;
    var reg_to = reg_toBox;
    var reg_thisWhole = document.regularization.reg_this.value;
    var reg_toWhole = document.regularization.reg_to.value;
    var choice = document.regularization.reg_choices.value;
    var newRule = "";
    var index = "";
    var rulesToAdd = {rules:[]};

    if(reg_thisWhole == "" || reg_toWhole == "")
    {
      alert("Invalid Rule");
      return false;
    }

    if(reg_toWhole[reg_toWhole.length] == " ")
    {
      reg_toWhole = reg_toWhole.substring(0, reg_toWhole.length-1);
    }

    if (reg_word != "" && reg_to != "")
    {
      if(choice == "this_place")
      {
        for (var i in distinct.witnesses)
        {
          if(reg_word == distinct.witnesses[i].token)
          {
             index = i;
          }
        }

        // get rule for each of the witnesses with this token
        for(var i in distinct.witnesses[index].originals)
        {
          for(var j in distinct.witnesses[index].originals[i].id)
          {
            //alert(id);
            id = distinct.witnesses[index].originals[i].id[j];
            newRule = createRule(choice, reg_thisWhole, reg_toWhole, reg_word, id, index);

            var add = true;
            for(var i in rulesToAdd.rules)
            {
              if(rulesToAdd.rules[i].scope == newRule.scope && rulesToAdd.rules[i].action == newRule.action && 
                  rulesToAdd.rules[i].token == newRule.token)
              {
                add = false;
              }
            }

            if(add)
            {
              rulesToAdd.rules.push(newRule);
            }
          }
        }

        for(var i in rulesToAdd.rules)
        {
          addRuleList(rulesToAdd.rules[i]);
        }
      }
      else
      {
        newRule = createRule(choice, reg_thisWhole, reg_toWhole, reg_word, "", "");
        addRuleList(newRule);
      }

    }

    contextStruct = { witnesses: [] };

    document.regularization.reg_this.value = "";
    //document.regularization.reg_to.value = "";
    document.regularization.reg_to.value = reg_toWhole;

    if(regOn)
    {
      insertRegTable(choice, reg_thisWhole, reg_toWhole);
      // without showing context --> may need to do for each rule added
      // if there are different ones for different witnesess 
      // (different context)
//      if(choice != "this_place")
//      {
//        insertRegTable(choice, reg_thisWhole, reg_toWhole);
//      }
//      else
//      {
//        action = newRule.action;
//        reg_this = action.split(',')[0];
//        reg_this = reg_this.substring(11,reg_this.length);
//        reg_to = action.split(', ')[1];
//        reg_to = reg_to.substring(0, reg_to.length-1);
//        insertRegTable(choice, reg_this, reg_to);
//      }
    }

    //console.log(newRules);

    changeRegularizeLabel(choice, reg_thisWhole, reg_toWhole);
  }
  else
  {
    alert("Turn regularization on to add new rules");
  }
}

function addRuleList(newRule)
{ 
  sendRule(newRule);
  
  if(isCustomRules)
  {
    customRules.rules.push(newRule);
    allRules.rules.push(newRule);
    newRules.rules.push(newRule);
    regularize(customRules);
  }
  else if(regOn && !isCustomRules)
  {
    allRules.rules.push(newRule);
    var regRules = allRules;
    //CHANGED: check works!
    newRules.rules.push(newRule);
    regularize(regRules);
  }
  else
  {
    allRules.rules.push(newRule);
    newRules.rules.push(newRule);
    regularize(newRules);
  }

}

/*
 * id: id of the witness getting context for
 * index: index in the distinct.witnesses list (for token)
 */
function getContext(id, index)
{ 
  
  var needMoreContext = false;
  var context = "";
  var contextIndex;
  var origContext = "";
  
  // find the context that relate to the id
  for(var i in contextStruct.witnesses)
  {
    if(contextStruct.witnesses[i].id == id)
    {
      context = contextStruct.witnesses[i].context;
      origContext = context;
      context = context.split(/\W/);
      context = context.join(' ');
      contextIndex = i;
    }
  }
  var re = new RegExp(context, 'g');
  
  // find if the context matches any witnesses
  // if it matches any witnesses that are not to be 
  // regularize --> needMoreContext
  // if there are more than one match in a witness to 
  // be regularized --> needMoreContext
  for(var i in allWitnesses.witnesses)
  {
    var witness = allWitnesses.witnesses[i].content.split(/\W/).join(' ');
    var result = witness.match(re);
    var isId = false;
    
    if(result)
    {
      for(var j in distinct.witnesses[index].originals)
      {
        for(var k in distinct.witnesses[index].originals[j].id)
        {
          dWid = distinct.witnesses[index].originals[j].id[k];
          if(dWid == allWitnesses.witnesses[i].id)
          {
            isId = true;
            if(result.length > 1)
            {
              needMoreContext = true;
            }
          }
        }
      }
      
      if(!isId)
      {
        needMoreContext = true;
      }
    }
  }
  
  if(needMoreContext)
  {
    returnContext = getMoreContext(id, index, contextIndex);
    if(returnContext)
    {
      return context = getContext(id, index);
    }
    else
    {
      return origContext;
    }
  }
  else
  {
    return origContext;
  }
  
}

/*
 * id: id of the witness getting context for
 * index: index in the distinct.witnesses list (for token)
 * witnessIndex: index into the contextStruct
 */
function getMoreContext(id, index, witnessIndex)
{
  //alert("getMoreContext");
  
  var tokenWitnessIndex;
  for (var i in allWitnesses.witnesses)
  {
    if(allWitnesses.witnesses[i].id == id)
    {
      tokenWitnessIndex = i;
    }
  }

  if(contextStruct.witnesses[witnessIndex].startPos == 1 && contextStruct.witnesses[witnessIndex].maxPos == totalPos)
  {
    // total context
    return false;
  }
  else if (contextStruct.witnesses[witnessIndex].startPos == 1 && contextStruct.witnesses[witnessIndex].endPos != totalPos)
  {
    contextStruct.witnesses[witnessIndex].endPos++;
    if(allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].endPos] != null)
    {
      contextStruct.witnesses[witnessIndex].context += " " + allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].endPos].t;
    }
    contextStruct.witnesses[witnessIndex].switchDirections = false;
  }
  else if (contextStruct.witnesses[witnessIndex].endPos == totalPos && contextStruct.witnesses[witnessIndex].startPos != 1)
  {
    contextStruct.witnesses[witnessIndex].startPos--;
    if(allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].startPos] != null)
    {
      contextStruct.witnesses[witnessIndex].context = allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].startPos].t + " " + contextStruct.witnesses[witnessIndex].context;
    }
    contextStruct.witnesses[witnessIndex].switchDirections = false;
  }
  else if (contextStruct.witnesses[witnessIndex].goForward == true && contextStruct.witnesses[witnessIndex].endPos != totalPos)
  {
    contextStruct.witnesses[witnessIndex].goForward = false;
    contextStruct.witnesses[witnessIndex].endPos++;
    if(allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].endPos] != null)
    {
      contextStruct.witnesses[witnessIndex].context += " " + allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].endPos].t;
    }
  }
  else if (contextStruct.witnesses[witnessIndex].goForward == false && contextStruct.witnesses[witnessIndex].startPos != 1)
  {
    contextStruct.witnesses[witnessIndex].goForward = true;
    contextStruct.witnesses[witnessIndex].startPos--;
    if(allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].startPos] != null)
    {
      contextStruct.witnesses[witnessIndex].context = allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].startPos].t + " " + contextStruct.witnesses[witnessIndex].context;
    }
  }

  return true;
}

function sendRule(newRule)
{
  var sendRules = {rules: []};
  sendRules.rules.push(newRule);
  sendRules.urn = urn;
  sendRules.userName = userName;
  sendRules.ruleSetName = ruleSetName;
  
    $.post("http://127.0.0.1:8000/regularization/postNewRule/",
       JSON.stringify(sendRules), function(data){
       //alert("success");
     })
   .error(function () {alert("error: saveRules");})

}

function changeRegularizeLabel(choice, reg_thisWhole, reg_toWhole)
{
  
  changeLabelTimer = null;
  
  var scope = "";
  if(choice == "all_places")
  {
    scope = "all places in all witnesses.";
  }
  else if (choice == "this_entity")
  {
    scope = "all witnesses in this entity.";
  }
  else
  {
    scope = "all witnesses for this place.";
  }
  
  var content = "REGULARIZED:: \"" + reg_thisWhole + "\" to \"" + reg_toWhole + "\" in " + scope + "</br>";
  document.getElementById('newRegInfo').innerHTML = content;
  
  if (changeLabelTimer == null || !changeLabelTimer)
  {
    changeLabelTimer = setTimeout(function() {document.getElementById('newRegInfo').innerHTML = "";}, 5000);
  }
  
}

function regularize_onoff()
{
  
  if (regOn == false)
  {
     if(document.regularization.reg_checkbox.checked)
     {
       document.regularization.originals.style.visibility = "visible";
       document.getElementById("showOriginals").style.visibility = "visible";
       document.getElementById("showOriginals").innerHTML = "Show originals";
       document.edit_reg.style.visibility = "hidden";
     }
     regOn = true;
     document.getElementById('reg_on').innerHTML = "Regularization is on! Click on a witness for a regularized word to see more detail.";
     document.getElementById('reg_button').value = "Reg. Off";
     
     if(isRecollate)
     {
       recollate();
       isRecollate = false;
     }

     loadRegTable();
  
     if(isCustomRules)
      {
          regularize(customRules);
      }
      else
      {
          regularize(allRules);
      }

  }
  else
  {
     if(document.regularization.reg_checkbox.checked)
     {
       document.regularization.originals.style.visibility = "hidden";
       document.getElementById("showOriginals").style.visibility = "hidden";
     }
     
     regOn = false;
     string = "Regularization is off! (Showing originals)";
     document.getElementById('reg_on').innerHTML = string;
     document.getElementById('reg_button').value = "Reg. On";
     
     //document.information.style.visibility = "hidden";
     document.edit_reg.style.visibility = "hidden";
     
     //TODO: getBaseTokens!!
     allTokens = origTokens;
     
     if(isCustomRules)
     {
       regularize(customRules);
     }
     else
     {
       newRules = { rules: [] };
       regularize(newRules);
     }
  }
}

function regularize(regRules)
{

  var position = currentPosition;
  
  content = findDistinct(position, regRules);
  
  if(!isRealign)
  {
    automateReg(document.getElementById("automate"));
  }
  
  //console.log(distinct);

  document.regularization.reg.value = content;
  
}

function findDistinct(position, regRules)
{
  distinct = {witnesses:[]};
  
  for (var i in allTokens.alignment)
  {
    var regToken = false;
    var origToken = "";
    var added = false;
    var token = "";

    // get token from json
    if(allTokens.alignment[i].tokens[position] == null)
    {
       origToken = "null";
    }
    else
    {
      origToken = allTokens.alignment[i].tokens[position].t;
    }

    // regularize token
    var token = getToken(regRules, i, position);
    

    // determine what the original token is, if it is regularized
    if(origToken != token)
    {
      regToken=true;
    }
    
    if(allTokens.alignment[i].tokens[position] != null)
    {
      if(allTokens.alignment[i].tokens[position].origToken != "" && allTokens.alignment[i].tokens[position].origToken != undefined)
      {
        regToken = true;
        origToken = allTokens.alignment[i].tokens[position].origToken;
      }
    }
    
    // search if token is already in the array
    // if is ... add after
    for(var j in distinct.witnesses)
    {
      var distinctToken = distinct.witnesses[j].token;
      
      if(token == distinctToken && !added)
      {
        for( var k in distinct.witnesses[j].originals)
        {
          //console.log(distinct);
          if(origToken == distinct.witnesses[j].originals[k].origToken && !added)
          {
            distinct.witnesses[j].originals[k].id.push(allTokens.alignment[i].witness);
            added = true;
          }
        }
        if(!added)
        {
          distinct.witnesses[j].originals.push({
            "origToken": origToken,
            "id": []
          });
          
          var index = distinct.witnesses[j].originals.length-1;
          distinct.witnesses[j].originals[index].id.push(allTokens.alignment[i].witness);
          added = true;
        }
      }
    }
    
    // add token to array because it is the first one
    if(i==0)
    {
      distinct.witnesses.push({
        "token": token,
        "originals": []
      });
      
      distinct.witnesses[i].originals.push({
        "origToken": origToken,
        "id" : []
      });
      
      distinct.witnesses[i].originals[i].id.push(allTokens.alignment[i].witness);
      added = true;
    }
    // not already in array ... add token and id to it
    else if (!added)
    {
      distinct.witnesses.push({
        "token": token,
        "originals": []
      });
      
      for(var j in distinct.witnesses)
      {
        if(distinct.witnesses[j].token == token && !added)
        {
          distinct.witnesses[j].originals.push({
            "origToken": origToken,
            "id" : []
          });
          
          var index = distinct.witnesses[j].originals.length-1;
          distinct.witnesses[j].originals[index].id.push(allTokens.alignment[i].witness);
        }
      }
    }
  }
  
  // create the content for the collation area text box
  var content = "";
  for (var i in distinct.witnesses)
  {
    content += distinct.witnesses[i].token;
    
    for(var j in distinct.witnesses[i].originals)
    {
      if(distinct.witnesses[i].originals[j].origToken != distinct.witnesses[i].token && isOriginals)
      {
        for(var k in distinct.witnesses[i].originals[j].id)
        {
          content += " " + distinct.witnesses[i].originals[j].id[k];
        }

        content += "(" + distinct.witnesses[i].originals[j].origToken + "), ";
      }
      else
      {
        for(var k in distinct.witnesses[i].originals[j].id)
        {
          content += " " + distinct.witnesses[i].originals[j].id[k];
        }
        if(isOriginals)
        {
          content += ",";
        }
      }
    }
    
    content += " /// "; 
  }
 
  return content;
  
}

//http://www.openjs.com/scripts/events/keyboard_shortcuts/
shortcut = {
	'all_shortcuts':{},//All the shortcuts are stored in this array
	'add': function(shortcut_combination,callback,opt) {
		//Provide a set of default options
		var default_options = {
			'type':'keydown',
			'propagate':false,
			'disable_in_input':false,
			'target':document,
			'keycode':false
		}
		if(!opt) opt = default_options;
		else {
			for(var dfo in default_options) {
				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
			}
		}

		var ele = opt.target;
		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
		var ths = this;
		shortcut_combination = shortcut_combination.toLowerCase();

		//The function to be called at keypress
		var func = function(e) {
			e = e || window.event;
			
			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
				var element;
				if(e.target) element=e.target;
				else if(e.srcElement) element=e.srcElement;
				if(element.nodeType==3) element=element.parentNode;

				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
			}
	
			//Find Which key is pressed
			if (e.keyCode) code = e.keyCode;
			else if (e.which) code = e.which;
			var character = String.fromCharCode(code).toLowerCase();
			
			if(code == 188) character=","; //If the user presses , when the type is onkeydown
			if(code == 190) character="."; //If the user presses , when the type is onkeydown

			var keys = shortcut_combination.split("+");
			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
			var kp = 0;
			
			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
			var shift_nums = {
				"`":"~",
				"1":"!",
				"2":"@",
				"3":"#",
				"4":"$",
				"5":"%",
				"6":"^",
				"7":"&",
				"8":"*",
				"9":"(",
				"0":")",
				"-":"_",
				"=":"+",
				";":":",
				"'":"\"",
				",":"<",
				".":">",
				"/":"?",
				"\\":"|"
			}
			//Special Keys - and their codes
			var special_keys = {
				'esc':27,
				'escape':27,
				'tab':9,
				'space':32,
				'return':13,
				'enter':13,
				'backspace':8,
	
				'scrolllock':145,
				'scroll_lock':145,
				'scroll':145,
				'capslock':20,
				'caps_lock':20,
				'caps':20,
				'numlock':144,
				'num_lock':144,
				'num':144,
				
				'pause':19,
				'break':19,
				
				'insert':45,
				'home':36,
				'delete':46,
				'end':35,
				
				'pageup':33,
				'page_up':33,
				'pu':33,
	
				'pagedown':34,
				'page_down':34,
				'pd':34,
	
				'left':37,
				'up':38,
				'right':39,
				'down':40,
	
				'f1':112,
				'f2':113,
				'f3':114,
				'f4':115,
				'f5':116,
				'f6':117,
				'f7':118,
				'f8':119,
				'f9':120,
				'f10':121,
				'f11':122,
				'f12':123
			}
	
			var modifiers = { 
				shift: { wanted:false, pressed:false},
				ctrl : { wanted:false, pressed:false},
				alt  : { wanted:false, pressed:false},
				meta : { wanted:false, pressed:false}	//Meta is Mac specific
			};
                        
			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
			if(e.shiftKey)	modifiers.shift.pressed = true;
			if(e.altKey)	modifiers.alt.pressed = true;
			if(e.metaKey)   modifiers.meta.pressed = true;
                        
			for(var i=0; k=keys[i],i<keys.length; i++) {
				//Modifiers
				if(k == 'ctrl' || k == 'control') {
					kp++;
					modifiers.ctrl.wanted = true;

				} else if(k == 'shift') {
					kp++;
					modifiers.shift.wanted = true;

				} else if(k == 'alt') {
					kp++;
					modifiers.alt.wanted = true;
				} else if(k == 'meta') {
					kp++;
					modifiers.meta.wanted = true;
				} else if(k.length > 1) { //If it is a special key
					if(special_keys[k] == code) kp++;
					
				} else if(opt['keycode']) {
					if(opt['keycode'] == code) kp++;

				} else { //The special keys did not match
					if(character == k) kp++;
					else {
						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
							character = shift_nums[character]; 
							if(character == k) kp++;
						}
					}
				}
			}
			
			if(kp == keys.length && 
						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
						modifiers.shift.pressed == modifiers.shift.wanted &&
						modifiers.alt.pressed == modifiers.alt.wanted &&
						modifiers.meta.pressed == modifiers.meta.wanted) {
				callback(e);
	
				if(!opt['propagate']) { //Stop the event
					//e.cancelBubble is supported by IE - this will kill the bubbling process.
					e.cancelBubble = true;
					e.returnValue = false;
	
					//e.stopPropagation works in Firefox.
					if (e.stopPropagation) {
						e.stopPropagation();
						e.preventDefault();
					}
					return false;
				}
			}
		}
		this.all_shortcuts[shortcut_combination] = {
			'callback':func, 
			'target':ele, 
			'event': opt['type']
		};
		//Attach the function with the event
		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
		else ele['on'+opt['type']] = func;
	},

//Remove the shortcut - just specify the shortcut and I will remove the binding
	'remove':function(shortcut_combination) {
		shortcut_combination = shortcut_combination.toLowerCase();
		var binding = this.all_shortcuts[shortcut_combination];
		delete(this.all_shortcuts[shortcut_combination])
		if(!binding) return;
		var type = binding['event'];
		var ele = binding['target'];
		var callback = binding['callback'];

		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
		else ele['on'+type] = false;
	}
}

function findNextVariant()
{
  var reg_to = document.regularization.reg_to.value;

  var position = currentPosition;
  var regRules = "";

  if(isCustomRules)
  {
    regRules = customRules;
  }
  else
  {
    regRules = newRules;

    if(regOn)
    {
      for(var i in allRules.rules)
      {
        regRules.rules.push(allRules.rules[i]);
      }
    }
  }

  if(reg_to == "")
  {
    alert("Please select a token");
  }
  else
  {
     reg_to = reg_to.split(" ", 1);
     var found = false;
     var foundVariant = false;
     var variant = "";
     for (var i in allTokens.alignment)
     {
       var token = getToken(regRules, i, position);

       if (token == reg_to && !found)
       {
         found = true;
       }
       else if (found && reg_to != token && !foundVariant)
       {
           foundVariant = true;
           variant = token;
           reg_thisBox = token;
       }
     }
     if(foundVariant)
     {
       document.regularization.reg_this.value = "";
       document.regularization.reg_this.value = variant;
     }
     else
     {
       alert("Error: Cannot get next variant.");
     } 
   }
}

function addTokenTo()
{
    // if more than one winess, check to see if words are different
    // if words are different -> cannot add next word
    // else add next word to reg_this
    // if reg_on see if rules apply to next word!

  var reg_this = document.regularization.reg_to.value;
  var position = currentPosition;
  var newToken = "";
  var regRules = "";

  if(isCustomRules)
  {
    regRules = customRules;
  }
  else
  {
    regRules = newRules;

    if(regOn)
    {
      for(var i in allRules.rules)
      {
        regRules.rules.push(allRules.rules[i]);
      }
    }
  }
  
  var reg_thisArray = reg_this.split(" ");
  var newPosition = currentPosition-1;
  newPosition += reg_thisArray.length;

  if(reg_this == "")
  {
    alert("Please select a token");
  }
  else if(newPosition >= totalPos)
  {
    alert("Cannot add next token: There are no more tokens in entity!");
  }
  else
  {
     position--;
     for(var i in reg_thisArray)
     {
       reg_this = reg_thisArray[i];
       position++;
     }
  
     var add = true;
     var found = false;

     for (var i in allTokens.alignment)
     {
       var token = getToken(regRules, i, position);
        
        if(token == reg_this)
        {
         var newPosition = position + 1;
         var rToken = getToken(regRules, i, newPosition);

          if(!found)
          {
           	found = true;
           	newToken = rToken;
          }
          else if(found && rToken != newToken)
          {
            add = false;
          }
         }
    }

     if(add)
     {
       document.regularization.reg_to.value += " " + newToken;
     }
     else
     {
       alert("Error: Cannot get next token.  Not all next tokens match.");
     } 
  }

}

function addTokenThis()
{
    // if more than one winess, check to see if words are different
    // if words are different -> cannot add next word
    // else add next word to reg_this
    // if reg_on see if rules apply to next word!

  var reg_this = document.regularization.reg_this.value;
  var position = currentPosition;
  var newToken = "";
  var regRules = "";

  if(isCustomRules)
  {
    regRules = customRules;
  }
  else
  {
    regRules = newRules;

    if(regOn)
    {
      for(var i in allRules.rules)
      {
        regRules.rules.push(allRules.rules[i]);
      }
    }
  }
  
  var reg_thisArray = reg_this.split(" ");
  var newPosition = currentPosition-1;
  newPosition += reg_thisArray.length;

  if(reg_this == "")
  {
    alert("Please select a token");
  }
  else if(newPosition >= totalPos)
  {
    alert("Cannot add next token: There are no more tokens in entity!");
  }
  else
  {
     position--;
     for(var i in reg_thisArray)
     {
       reg_this = reg_thisArray[i];
       position++;
     }
  
     var add = true;
     var found = false;

     for (var i in allTokens.alignment)
     {
       var token = getToken(regRules, i, position);
        
        
        if(token == reg_this)
        {
          var newPosition = position + 1;
          var rToken = getToken(regRules, i, newPosition);

          if(!found)
          {
           	found = true;
           	newToken = rToken;
          }
          else if(found && rToken != newToken)
          {
            add = false;
          }
         }
    }

     if(add)
     {
       document.regularization.reg_this.value += " " + newToken;
     }
     else
     {
       alert("Error: Cannot get next token.  Not all next tokens match.");
     } 
  }
}

function buildWitnesses()
{
  //alert("buildWitnesses");
  newWitnesses = { witnesses: [] };
  var regRules;
  if(isCustomRules)
  {
    regRules = customRules;
  }
  else
  {
    regRules = allRules;
  }
  isBuildWitnesses = true;
  allTokens = origTokens;

  for (var i in allTokens.alignment)
  {
    var content = "";
    for (var j in allTokens.alignment[i].tokens)
    {
      var token = getToken(regRules, i, j);
      if(token != "null")
      {
        content += token + " ";
      }
    }

    content = content.substring(0, content.length-1);
    newWitnesses.witnesses.push ({
      "id": allTokens.alignment[i].witness,
      "content": content
    });
  }
  
  isBuildWitnesses=false;

  return newWitnesses;
}

function seeWitnesses()
{

  newWitnesses = buildWitnesses();
  newWitnesses.userName = userName;
  newWitnesses.urn = urn;
  newWitnesses.ruleSetName = ruleSetName;
  newWitnesses.witnessesTokens = witnessDataTokens;
  newWitnesses.witnessesLines = witnessDataLines;
  newWitnesses.ruleSet = {ruleSet : allRules};
  newWitnesses.position = currentPosition;

  $.ajax({
    url: "http://127.0.0.1:8000/regularization/postEntireReg/",
    dataType: 'json',
    type: 'POST',
    async: false,
    data: JSON.stringify(newWitnesses),
    success: function(data){
    }});
  
  window.location.href = "http://127.0.0.1:8000/regularization/viewEntireReg/";
  
}

function recollate()
{  
  isRecollate = false;
  var newWitnesses = buildWitnesses();
  newWitnesses = JSON.stringify(newWitnesses);
  
  $.ajax({
    url: "http://127.0.0.1:8000/regularization/postRecollate/",
    dataType: 'json',
    type: 'post',
    async: false,
    data: newWitnesses,
    success: function(data){
    }});
  
  
  $.ajax({
    url: "http://127.0.0.1:8000/regularization/sendRecollate/",
    dataType: 'json',
    async: false,
    success: function(data){
      for(var i in data.alignment)
      {
        for(var j in data.alignment[i].tokens)
        {
            for(var k in allTokens.alignment[i].tokens)
            {
              if(allTokens.alignment[i].tokens[k] != null && data.alignment[i].tokens[j] != null)
              {
                if(allTokens.alignment[i].tokens[k].t == data.alignment[i].tokens[j].t)
                {
                  data.alignment[i].tokens[j].origToken = allTokens.alignment[i].tokens[k].origToken;
                }
              }
            }
        }
      }
      
      allTokens = data;
      
      totalPos = allTokens.alignment[0].tokens.length;
      
 }});
}

function checkSpaces(reg_word)
{
  
  var position = 0;
  var i = -1;
  var indices = [];
  
  while (position != -1)
  {
    position = reg_word.indexOf(" ", i + 1);
    if(position != -1)
    {
      indices.push(position);
    }
    i = position;
  }
  
  if(indices == [])
  {
    return false;
  }
  else
  {
    return indices;
  }
}

function getToken(regRules, witnessId, position)
{

   var token = "";
   var collate = false;
   var origToken = "";
  
   if(allTokens.alignment[witnessId].tokens[position] == null)
   {
     token = "null";
   }
   else
   {
     token = allTokens.alignment[witnessId].tokens[position].t;
   }

   for (var k in regRules.rules)
   {
     var modifications = regRules.rules[k].modifications;
     if (modifications[modifications.length-1].modification_type == "delete")
     {
      isDisabled = true; 
     }
     else if (token == regRules.rules[k].token)
     {
        action = regRules.rules[k].action;
        reg_this = action.split(',')[0];
        reg_this = reg_this.substring(11,reg_this.length);
        reg_to = action.split(', ')[1];
        reg_to = reg_to.substring(0, reg_to.length-1);
        wholeToToken = reg_to;
        choice = regRules.rules[k].scope;
        
        if(choice == "this_place")
        {
          var found = false;
          var reg_thisIndex = -1;
          var reg_thisArray = reg_this.split(" ");
          for(var m in reg_thisArray)
          {
            if(reg_thisArray[m] == token && !found)
            {
              found = true;
              reg_thisIndex = m;
              
            }
          }
          if(found)
          {
            reg_thisArray.splice(0, reg_thisIndex);
          }
          origToken = reg_thisArray[0];
          reg_thisArray = reg_thisArray.join(" ");
          
          found = false;
          var reg_thisArray2 = reg_this.split(" ");
          var reg_toArray = reg_to.split(" ");
          var reg_toIndex = -1;
          
          for(var m in reg_toArray)
          {
            if(reg_toArray[m] != reg_thisArray2[m] && !found)
            {
              found = true;
              reg_toIndex = m;
            }
          }
          if(found)
          {
            reg_toArray.splice(0, reg_toIndex);
          }
          reg_toArray = reg_toArray.join(" ");
          
          reg_this = reg_thisArray;
          reg_to = reg_toArray;
          
        }
        
        var spacesThis = checkSpaces(reg_this);
        var spacesTo = checkSpaces(reg_to);
        
        if(spacesThis != false)
        {
            //Check if next word(s) match
            // if match -> recollate

            var content = token;

            for (var i in spacesThis)
            {
              position++;
              if(allTokens.alignment[witnessId].tokens[position] == null)
              {
                newToken = "null";
              }
              else
              {
                newToken = allTokens.alignment[witnessId].tokens[position].t;
              }
              content += " " + newToken;
            }

            if(content == reg_this)
            {
              position = currentPosition;
              if(origToken == "")
              {
                origToken = reg_this;
              }
              allTokens.alignment[witnessId].tokens[position].t = reg_to;
              allTokens.alignment[witnessId].tokens[currentPosition].origToken = origToken;
              allTokens.alignment[witnessId].tokens[currentPosition].reg_to = reg_to;

              //console.log(allTokens);
              position++;
              for(var k in spacesThis)
              { 
                allTokens.alignment[witnessId].tokens.splice(position, 1);
              }
              collate = true;
            }
		  
        }
        else
        {
          token = reg_to;
        }
        
        if(spacesTo != false && !isBuildWitnesses)
        {
            //Check if next word(s) match
            // if match -> recollate

            var content = reg_to;
            //alert("spacesTo");

            content = content.split(' ').join('');

            //alert(content + " " + reg_this + " " + reg_to);

            if(content == reg_this)
            {
              var insertTokens = reg_to.split(' ');
              var position = currentPosition;
              for(var k in insertTokens)
              {
                if(k == 0)
                {
                  if(origToken == "")
                  {
                    origToken = reg_this;
                  }
                  
                  if(allTokens.alignment[witnessId].tokens[position] != null)
                  {
                    allTokens.alignment[witnessId].tokens[position].t = insertTokens[k];
                    allTokens.alignment[witnessId].tokens[position].origToken = origToken;
                    allTokens.alignment[witnessId].tokens[position].reg_to = reg_to;
                  }
                  else
                  {
                    var insertTok = { "t" : insertTokens[k], "n" : insertTokens[k], "origToken" : origToken, "reg_to" : reg_to};
                    allTokens.alignment[witnessId].tokens.splice(position,1,insertTok);
                  }
                }
                else
                {
                  if(origToken == "")
                  {
                    origToken = reg_this;
                  }
                  var insertTok = { "t" : insertTokens[k], "n" : insertTokens[k], "origToken" : origToken, "reg_to" : reg_to};
                  allTokens.alignment[witnessId].tokens.splice(position,0,insertTok);
                }
                position++;
              }

              reg_to = reg_to.split(' ')[0];
              collate = true;
              token = reg_to;

            }
        }
        else if(spacesTo != false && isBuildWitnesses)
        {
          token = wholeToToken;
        }
        else
        {
          reg_to = reg_to.split(' ')[0];
          token = reg_to;
        }
      }
    }
    
    if(collate)
    {
      collate = false;
      if(!isBuildWitnesses)
      {
      	//recollate();
      	isRecollate = false;
        reg_to = reg_to.split(' ')[0];
      	token = reg_to;
      }
    }
    
    return token;
}

function informationWindow(witnessId)
{
  var regInfo = { data: [] };
  var context = "";
  var index = "";
  var position = currentPosition;
  var regRules = "";
  var token = "";
  var temp = urn.split("entity=")[1];
  var entity = temp.split(":", 1)[0];
  var line = temp.split("Line=")[1];
  
  witnessId = witnessId.split('(')[0];
  
  for (var i in allWitnesses.witnesses)
  {
    if(witnessId == allWitnesses.witnesses[i].id)
    {
      context = allWitnesses.witnesses[i].content;
      index = i;
    }
  }
  
  if(isCustomRules && regOn)
  {
    regRules = customRules;
  }
  else if(regOn)
  {
    regRules = allRules;
  }
  else
  {
    regRules = {rules: []};
  }
  
  var reg_this = "";
  var reg_to = "";
  var choice = "";
  
  for(var i in regRules.rules)
  {
    var action = regRules.rules[i].action;
    
    if(allTokens.alignment[index].tokens != null && allTokens.alignment[index].tokens[currentPosition] != null)
    {
      if(allTokens.alignment[index].tokens[currentPosition].origToken != null && allTokens.alignment[index].tokens[currentPosition].origToken != "")
      {
        reg_this = action.split(', ')[0];
        reg_this = reg_this.substring(11, reg_this.length);
        if(allTokens.alignment[index].tokens[currentPosition].origToken == reg_this)
        {
          reg_to = action.split(', ')[1];
          reg_to = reg_to.substring(0, reg_to.length-1);
          choice = regRules.rules[i].scope;
        }
      }
      else 
      {
        if (allTokens.alignment[index].tokens[currentPosition] != null)
        {
          token = allTokens.alignment[index].tokens[currentPosition].t;
        }
        else
        {
          token = "null";
        }

        if(token == regRules.rules[i].token)
        {
          reg_this = regRules.rules[i].token;
          reg_to = action.split(', ')[1];
          reg_to = reg_to.substring(0, reg_to.length-1);
          choice = regRules.rules[i].scope;
        }
      }
    }
    else
    {
      token = "null";
    }
  }
  
  if(choice == "all_places")
  {
    choice = "all places in all witnesses";
  }
  else if(choice == "this_entity")
  {
    choice = "this entity in all witnesses";
  }
  else if(choice == "this_place")
  {
    choice = "this place in all witnesses";
  }
  
  document.information.style.visibility = "visible";
  document.reg_information.style.visibility ="hidden";
  document.getElementById('witnessId').innerHTML = witnessId;
  document.getElementById('word').innerHTML = position;
  document.getElementById('line').innerHTML = line;
  document.getElementById('block').innerHTML = entity; 
  document.getElementById('context').innerHTML = context;
  
  if(reg_this != "" && reg_to != "" && choice != "")
  {
    document.reg_information.style.visibility = "visible";
    document.getElementById('reg_this_info').innerHTML = reg_this;
    document.getElementById('reg_to_info').innerHTML = reg_to;
    document.getElementById('choice').innerHTML = choice;
  }
  
}

function loadRegTable()
{
  var regRules = { rules: [] };
  
  regRules = allRules;
  
//  for(var i in newRules.rules)
//  {
//    regRules.rules.push(newRules.rules[i]);
//  }

  //delete everything out of reg_table
   var table = document.getElementById('reg_table');
   var rowCount = table.rows.length;
   for(var i =rowCount-1; i>=0; i--)
   {
     table.deleteRow(i);
   }

  var table = document.getElementById('reg_table');

  var rowCount = table.rows.length;
  var row = table.insertRow(rowCount);
  
  var checkCellTitle = row.insertCell(0);
  var scopeCellTitle = row.insertCell(1);
  scopeCellTitle.innerHTML = "Scope";
  var regThisCellTitle = row.insertCell(2);
  regThisCellTitle.innerHTML = "Reg. This";
  var regToCellTitle = row.insertCell(3);
  regToCellTitle.innerHTML = "Reg. To";
  var deleteCellTitle = row.insertCell(4);
  deleteCellTitle.innerHTML = "Delete";
  
  rowCount++; 
  
  for(var i in regRules.rules)
  {
    var scope = regRules.rules[i].scope;
    var reg_this = regRules.rules[i].token;
    var reg_to = "";
    action = regRules.rules[i].action;
    reg_this = action.split(',')[0];
    reg_this = reg_this.substring(11,reg_this.length);
    reg_to = action.split(', ')[1];
    reg_to = reg_to.substring(0, reg_to.length-1);
    var modifications = regRules.rules[i].modifications;
    var isDisabled = false;
    if (modifications[modifications.length-1].modification_type == "delete")
    {
      isDisabled = true; 
    }
    
    insertRegTable(scope, reg_this, reg_to, isDisabled);
  	
  	rowCount++;
  }
  
  document.edit_reg.style.visibility = "visible";
}

function insertRegTable(scope, reg_this, reg_to, isDisabled)
{
    if(reg_this == null)
    {
      reg_this = "null";
    }
    
    if(reg_to == null)
    {
      reg_to = "null";
    }
    
    var found = true;
    if(isCustomRules)
    {
      found = false;
      //alert("isCustom: insertRegTable"); 
      
      for(var i in customRules.rules)
      {
        var customScope = customRules.rules[i].scope;
      	var action = customRules.rules[i].action;
        var reg_thisRule = action.split(',')[0];
        reg_thisRule = reg_thisRule.substring(11,reg_thisRule.length);
        var reg_toRule = action.split(', ')[1];
        reg_toRule = reg_toRule.substring(0, reg_toRule.length-1);
        var scopeRule = customRules.rules[i].scope;
	  	
        //TODO: add more when completed rules
        if(customScope == scope && reg_this == reg_thisRule && reg_to == reg_toRule)
        {
          found = true;
        }
      }
    }
    
    var table = document.getElementById('reg_table');

    var rowCount = table.rows.length;
  	var row = table.insertRow(rowCount);
    
    var checkCell = row.insertCell(0);
  	var element1 = document.createElement("input");
  	element1.type = "checkbox";
  	if(found)
  	{
  	  element1.checked = "checked";
  	}
        if(isDisabled)
        {
          element1.disabled = true;
        }
  	checkCell.appendChild(element1);
  	
  	var scopeCell = row.insertCell(1);
  	var element2 = document.createElement("select");
  	var option1 = document.createElement("option");
  	option1.text = "All witnesses, this entity";
        if(isDisabled)
        {
          element2.disabled = true;
        }
  	element2.options.add(option1);
  	var option2 = document.createElement("option");
  	option2.text = "All witnesses, this place";
  	element2.options.add(option2);
  	var option3 = document.createElement("option");
  	option3.text = "All witnesses, all places";
  	element2.options.add(option3);
  	if(scope == "all_places")
  	{
  	  element2.selectedIndex = 2; 
  	}
  	else if (scope == "this_place")
  	{
  	  element2.selectedIndex = 1;
  	}
  	scopeCell.appendChild(element2);
  	
  	var regThisCell = row.insertCell(2);
  	var element3 = document.createElement("input");
  	element3.type = "text";
  	element3.size = "40";
  	//regThisCell.innerHTML = reg_this;
  	element3.value = reg_this;
        if(isDisabled)
        {
          element3.disabled = true;
        }
  	regThisCell.appendChild(element3);
  	
  	var regToCell = row.insertCell(3);
  	var element4 = document.createElement("input");
  	element4.type = "text";
  	element4.size = "40";
  	element4.value = reg_to;
        if(isDisabled)
        {
          element4.disabled = true;
        }
  	regToCell.appendChild(element4);
  	
  	
  	var deleteCell = row.insertCell(4);
  	deleteCell.align = "center";
  	var element5 = document.createElement("input");
  	element5.type = "checkbox";
  	//element5.checked = "checked";
        if(isDisabled)
        {
          element5.disabled = true;
        }
  	deleteCell.appendChild(element5);
        
  	/*
var deleteRegCell = row.insertCell(4);
  	var element5 = document.createElement("input");
  	element5.type = "button";
  	element5.value = "Delete";
  	deleteRegCell.appendChild(element5);
*/
  
}

function submitCustomReg()
{
  isCustomRules = true;  // ??!! <----
  var table = document.getElementById('reg_table');
  var rowCount = table.rows.length;
  
  customRules = { rules: [] };
  //first one is one to delete; second is new reg
  var sendRules = { rules: [] };
  
  var regRules = allRules;
//  for(var i in newRules.rules)
//  {
//    regRules.rules.push(newRules.rules[i]);
//  }
  //console.log(regRules);
  
  for(var i=1; i<rowCount; i++)
  {
    var row = table.rows[i];
    var check = row.cells[0].childNodes[0];
    var deleteRule = row.cells[4].childNodes[0];
    var index = i - 1;
    var scope = row.cells[1].childNodes[0].value;
    var reg_this = row.cells[2].childNodes[0].value;
    var reg_to = row.cells[3].childNodes[0].value;

    if(scope == "All witnesses, this entity")
    {
      scope = "this_entity";
    }
    else if(scope == "All witnesses, this place")
    {
      scope = "this_place";
    }
    else
    {
      scope = "all_places";
    }

    var action = regRules.rules[index].action;
    var reg_thisRule = action.split(',')[0];
    reg_thisRule = reg_thisRule.substring(11,reg_thisRule.length);
    var reg_toRule = action.split(', ')[1];
    reg_toRule = reg_toRule.substring(0, reg_toRule.length-1);
    var scopeRule = regRules.rules[index].scope;
    
    if(deleteRule != null && deleteRule.checked)
    {
      // delete from database
      var newRule = allRules.rules[index];
      newRule.modifications.push({
        "userId " : userName,
        "modification_type" : "delete",
        "dateTime" : getDateTime()
      });
      customRules.rules.push(newRule);
      sendRules.rules.push(newRule);
    }
    else if(check != null && check.checked)
    {
      if(reg_this == reg_thisRule && reg_to == reg_toRule && scope == scopeRule)
      {
        //add to customReg
        customRules.rules.push(regRules.rules[index]);
      }
      else
      {
        var rule = allRules.rules[index];
        var thisChange = false;
        if(reg_this != reg_thisRule)
        {
          rule.modifications.push({
            "userId": userName,
            "modification_type": "modify(reg_this," + reg_thisRule + "," + reg_this + ")",
            "dateTime": getDateTime()
          });
          sendRules.rules.push(rule);
          rule.action = "regularize(" + reg_this + "," + reg_toRule + ")";
          thisChange = true;
        }
        
        if(reg_to != reg_toRule)
        {
          rule.modifications.push({
            "userId": userName,
            "modification_type": "modify(reg_to," + reg_toRule + "," + reg_to + ")",
            "dateTime": getDateTime()
          });
          sendRules.rules.push(rule);
          if(thisChange)
          {
            rule.action = "regularize(" + reg_thisRule + "," + reg_to + ")";
          }
          else
          {
            rule.action = "regularize(" + reg_this + "," + reg_to + ")"; 
          }
        }
        
        if(scope != scopeRule)
        {
          rule.modifications.push({
            "userId": userName,
            "modification_type": "modify(scope," + scopeRule + "," + scope + ")",
            "dateTime": getDateTime()
          });
          sendRules.rules.push(rule);
          rule.scope = scope;
        }
        
        customRules.rules.push(rule)

      }
    }
    
    sendRules.urn = urn;
    sendRules.userName = userName;
    sendRules.ruleSetName = ruleSetName;

    // send changed rules to server
    $.ajax({
        url: "http://127.0.0.1:8000/regularization/changeRules/",
        dataType: 'json',
        type: 'POST',
        async: false,
        data: JSON.stringify(sendRules),
        success: function(data){
    }});
  
    sendRules = {rules:[]};
  }
  
  // get new/all rules and reload reg_table
  $.ajax({
        url: "http://127.0.0.1:8000/regularization/getBaseTokens/",
        dataType: 'json',
        async: false,
        success: function(data){
          allTokens = data;
        }
  });
  regularize(customRules);
  loadRegTable();
}

function getDateTime()
{
  var currentDate = new Date();
  var day = currentDate.getDate();
  var month = currentDate.getMonth() + 1;
  var year = currentDate.getFullYear();
  var hours = currentDate.getHours();
  var minutes = currentDate.getMinutes();
  var seconds = currentDate.getSeconds();
  var dateTime = hours + ":" + minutes + ":" + seconds + " " + month + "/" + day + "/" + year
  
  return dateTime;
}

  function createRule(scope, reg_this, reg_to, token, id, index)
{
 
  contextStruct = {witnesses:[]};
  var goForward;
  var context = reg_this;
  
  if(currentPosition == totalPos)
  {
    goForward = false;
  }
  else
  {
    goForward = true;
  }
  
  if(scope == "this_place")
  {
      contextStruct.witnesses.push({
        "id": id,
        "token": token,
        "context": reg_this,
        "tokenPos": currentPosition,
        "startPos": currentPosition,
        "endPos": currentPosition,
        "goForward": goForward,
        "switchDirections": true
        
      });
      context = getContext(id, index);
      
      var contextRegTo = context.replace(reg_this, reg_to);
      reg_to = contextRegTo;
  }
  
  dateTime = getDateTime();
  
  var action = "regularize(" + context + ", " + reg_to + ")";
  newRule = {
             "_id" : "",
             "appliesTo" : urn,
             "action" : action,
             "modifications" : [{
               "userId": userName,
               "modification_type": "create",
               "dateTime": dateTime
             }],
             "scope" : scope,
             "token" : token
           };
           
           
  console.log(newRule);
  return newRule;

}

function automateReg(checkBox)
{
  
  if(checkBox.checked)
  {
    autoReg = true; 
    
    var maxPosition = 0;
    var maxLength = 0;
    
    for (var i in distinct.witnesses)
    {
      var numberIds = 0;
      for(var j in distinct.witnesses[i].originals)
      {
        for(var k in distinct.witnesses[i].originals[j].id)
        {
          numberIds++;
        }
      }
       
      // nothing should ever be regularized to null
      if(numberIds > maxLength && distinct.witnesses[i].token != "null")
      {
        maxPosition = i;
        maxLength = numberIds;
      }
    }
   
    
    document.regularization.reg_to.value = distinct.witnesses[maxPosition].token;
    
    // null should never be regularized to anything ?!?
    if(distinct.witnesses[maxPosition] == "null")
    {
      maxPosition++;
    }
    
    if(maxPosition != distinct.witnesses.length-1)
    {
      maxPosition++;
      document.regularization.reg_this.value = distinct.witnesses[maxPosition].token;
    }
    else if(maxPosition != 0 && maxPosition == distinct.witnesses.length)
    {
      document.regularization.reg_this.value = distinct.witnesses[0].token;
    }
    
    reg_thisBox = document.regularization.reg_this.value;
    reg_toBox = document.regularization.reg_to.value;
    
  }
  else
  {
    autoReg = false;
    
    document.regularization.reg_this.value = "";
    document.regularization.reg_to.value = "";
  }
}

//function backEntity()
//{
//  if(lineNumber > 0)
//  {
//    lineNumber--;
//  }
//  getTokensWitnesses(false);
//  //shows all previously collated words and allows user to choose one to go to
//}
//
//function forwardEntity()
//{
//  lineNumber++;
//  getTokensWitnesses(true);
//}


function showOriginals(checkBox)
{ 
  if(checkBox.checked)
  {
    isOriginals = true;
    
    if(isCustomRules)
    {
      var regRules = customRules;
    }
    else
    {
      var regRules = allRules;
    }
    regularize(regRules);
    
  }
  else
  {
    isOriginals = false; 
    
    if(isCustomRules)
    {
      var regRules = customRules;
    }
    else
    {
      var regRules = allRules;
    }
    regularize(regRules);
  }
}

function showRegularization(checkBox)
{
  if(checkBox.checked)
  {
    document.getElementById("align_wrapper").innerHTML = "";
    document.regularization.change.checked = false;
    var regHTML = "<br /><br /><label id='reg_this'>Regularize This:</label>";
    regHTML += "<input type='text' name='reg_this' size='82'/> <br /><label id='reg_to'>To This:</label>";
    regHTML += "<input type='text' name='reg_to' size='92'/>";
    regHTML += "<p>Regularize Choices:";
    regHTML += "<select name='reg_choices'>";
    regHTML += "<option value='this_entity'>All witnesses, this entity</option>";
    regHTML += "<option value='this_place'>All witnesses, this place</option>";
    regHTML += "<option value='all_places'>All witnesses, all places</option>";
    regHTML += "<option value='other'>Other ...</option>";
    regHTML += "</select></p>";
    regHTML += "<input name='ok' type='button' value='Add Rule'";
    regHTML += "onclick='addRule()'>";
    regHTML += "<input name='recollateTokens' type='button' value='Recollate' onclick='recollate()'/>";
    regHTML += "<input name='view' type='button' value='View Entire Reg.' onclick='seeWitnesses()'>";
    regHTML += "<input name='done' type='button' value='Done'>";
    regHTML += "<br /> Shortcuts:: <br/>'Alt+Right Arrow': Add next word to Regularize This";
    regHTML += "<br /> 'Shift+Right Arrow': Add next word to Regularize To";
    regHTML += "<br /> 'Tab': Find next variant to regularize";
    regHTML += "<br /> 'Enter': Add rule";
    regHTML += "<br /> <input type='checkbox' name='automate' value='automate' id='automate'";
    regHTML += "onchange='automateReg(this)'/> Automate regularization selection";
    regHTML += "<br /> <input type='checkbox' name='originals' value='originals' onchange='showOriginals(this)'/>";
    regHTML += "<label id='showOriginals'>Show originals</label>";

    document.getElementById('reg_wrapper').innerHTML = regHTML;
    document.regularization.originals.style.visibility = "hidden";
    if(regOn)
    {
      document.edit_reg.style.visibility = "visible";
      document.getElementById("showOriginals").innerHTML = "Show originals";
      document.regularization.originals.style.visibility = "visible";
    }
    else
    {
      document.getElementById('showOriginals').innerHTML = "";
    }
  }
}

function showRealign(checkBox)
{
  
  if(checkBox.checked)
  {
    isRealign = true;
    //document.realign_token.style.visibility = "visible";
    document.regularization.reg_checkbox.checked = false;
    document.getElementById("reg_wrapper").innerHTML = "";
    
    var alignHTML = "Change token alignment: <input type='text' name='token' size='20'/>";
    alignHTML += "<br/>";
    alignHTML += "<input type='checkbox' name='forward_realign' value='forward_realign' id='forward_realign'";
    alignHTML += "onchange='alignmentDirection(this)'/> Forward";
    alignHTML += "<select name='forward_select' id='forward_select' onchange='getRealign()'></select>";
    alignHTML += "<br />";
    alignHTML += "<input type='checkbox' name='backward_realign' value='bacward_realign' id='backward_realign'";
    alignHTML += "onchange='alignmentDirection(this)'/> Backward";
    alignHTML += "<select name='backward_select' id='backward_select' onchange='getRealign()'></select>";
    alignHTML += "<br />";
    alignHTML += "Old alignment: <label id='realign_this'></label>";
    alignHTML += "<br />";
    alignHTML += "New alignment: <label id='realign_to'></label>";
    alignHTML += "<br />";
    alignHTML += "<input name='submitRealign' type='button' value='Change' onclick='realign()'>";
    
    document.getElementById("align_wrapper").innerHTML = alignHTML;
    document.getElementById("forward_select").style.visibility = "hidden";
    document.getElementById("backward_select").style.visibility = "hidden";
    document.edit_reg.style.visibility = "hidden";
  }
  else
  {
    isRealign = false;
  }
}

function alignmentDirection(checkBox)
{
  if(checkBox.value == "forward_realign")
  {
    document.getElementById("backward_realign").checked = false;
    document.getElementById("forward_select").style.visibility = "visible";
    document.getElementById("backward_select").style.visibility = "hidden";
    
    document.getElementById("forward_select").options.length = 0;
    var option = document.createElement("option");
    option.text = "--";
    document.getElementById("forward_select").add(option);
    var numPos = totalPos - currentPosition;
    for(var i = 0; i < numPos; i++)
    {
      var option = document.createElement("option");
      option.text = i+1;
      document.getElementById("forward_select").add(option);
    }
  }
  else
  {
    document.getElementById("forward_realign").checked = false;
    document.getElementById("forward_select").style.visibility = "hidden";
    document.getElementById("backward_select").style.visibility = "visible";
    
    document.getElementById("backward_select").options.length = 0;
    var option = document.createElement("option");
    option.text = "--";
    document.getElementById("backward_select").add(option);
    for(var i = 0; i <= currentPosition; i++)
    {
      var option = document.createElement("option");
      option.text = i+1;
      document.getElementById("backward_select").add(option);
    }
  }
}

function realign()
{
  var token = document.realign_token.token.value;
  var forward = document.getElementById("forward_select").value;
  var backward = document.getElementById("backward_select").value;
  
  if(token == "")
  {
    alert("Please select a token");
    return;
  }
  
  if(!regOn)
  {
    alert("Regularization must be on to change alignment");
    return;
  }
  
  if (token != "")
  {
    var ids = [];
    //console.log(distinct);

    for (var i in distinct.witnesses)
    {
      if(token == distinct.witnesses[i].token)
      {
        for (var j in distinct.witnesses[i].originals)
        {
          for (var k in distinct.witnesses[i].originals[j].id)
          {
            ids.push(distinct.witnesses[i].originals[j].id[k]);
          }
        }
      }
    }

    console.log(ids);

    if(document.getElementById("forward_realign").checked)
    {
      // add a null at currentPosition for this token(one to align), in each witness
      // **pushing this token to next position
      // add a null at end of tokens for each other witness
      // splice(index, howmany(0), item)
      for(var i in allTokens.alignment)
      {
        var foundId = false;
        for (var j in ids)
        {
          if(allTokens.alignment[i].witness == ids[j])
          {
            foundId = true;
          }
        }
        
        if(foundId)
        {
          // TODO: for number of positions
          for(var k = 0; k < forward; k++)
          {
            allTokens.alignment[i].tokens.splice(currentPosition, 0, null);
          }
        }
        else
        {
          for(var k = 0; k < forward; k++)
          {
            newPosition = totalPos + 1;
            allTokens.alignment[i].tokens.splice(newPosition, 0, null);
          }
        }
      }
    }
    else
    {
      // add a null at currentPosition for this token, in each witness
      // **pushin this token to previous position
      // add a null at currentPosition-1 for each other witness
      for(var i in allTokens.alignment)
      {
        var foundId = false;
        for (var j in ids)
        {
          if(allTokens.alignment[i].witness == ids[j])
          {
            foundId = true;
          }
        }
        
//       var position = currentPosition - 1;
        if(foundId)
        {
          newPosition = totalPos + 1;
          for(var k = 0; k < backward; k++)
          {
            console.log(newPosition);
            allTokens.alignment[i].tokens.splice(newPosition, 0, "null");
            newPosition++;
          }
          
          for(var k in allTokens.alignment[i].tokens)
          {
            if(allTokens.alignment[i].tokens[k] == "null")
            {
              allTokens.alignment[i].tokens[k] = null;
            }
          }
        }
        else
        {
          
          for(var k = 0; k < backward; k++)
          {
            allTokens.alignment[i].tokens.splice(0, 0, "null");
            allTokens.alignment[i].tokens[0] = null;
          }
        }
      }
    }
  }
  
  //TODO: customRules, regOn etc
  console.log(allTokens);
  regularize(allRules);
}

function getRealign()
{
  var token = document.realign_token.token.value;
  var oldAlign = "";
  var newAlign = "";
  var forward = document.getElementById("forward_select").value;
  var backward = document.getElementById("backward_select").value;
  var position = currentPosition;
  
  if(token == "")
  {
    alert("Please select a token");
    return;
  }
  
  if(!regOn)
  {
    alert("Regularization must be on to change alignment");
    return;
  }
  
  var newTokens = createNewAllTokens();
  var oldTokens = allTokens;
  allTokens = newTokens;
  
  if(document.getElementById("forward_realign").checked)
  {
    //OLDALIGN
    forward++;
    for(var i = 0; i<forward; i++)
    {
      if(position <= totalPos)
      { 
        //TODO: APPLY RULES DIFF -> IF CUSTOMRULES, etc
        oldAlign += findDistinct(position, allRules) + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
      else
      {
        oldAlign += getNullContent() + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
      position++;
    }
    
    //NEWALIGN
    //TODO: change for customRules, etc
    regularize(allRules);
    realign();
    position = currentPosition;
    for(var i = 0; i<forward; i++)
    {
      if(position <= totalPos)
      { 
        //TODO: APPLY RULES DIFF -> IF CUSTOMRULES, etc
        newAlign += findDistinct(position, allRules) + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
      else
      {
        newAlign += getNullContent() + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
      position++;
    }
  }
  else
  {
    //OLDALIGN
    position = position - backward;
    for(var i = 0; i <= backward; i++)
    {
      if(position >= -1)
      {
        // TODO: APPLY RULES DIFF -> IF CUSTOMRULES, etc
        oldAlign += findDistinct(position, allRules) + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
      else
      {
        oldAlign += getNullContent() + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
      position++;
    }
    
    //NEWALIGN
    position = currentPosition - backward + 1;
    //TODO: change for customRules, etc
    regularize(allRules);
    realign();
    for(var i = 0; i <= backward; i++)
    {
      if(position >= -1)
      {
        // TODO: APPLY RULES DIFF -> IF CUSTOMRULES, etc
        newAlign += findDistinct(position, allRules) + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
      else
      {
        newAlign += getNullContent() + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
      position++;
    }
  }
  
  document.getElementById("realign_this").innerHTML = oldAlign;
  document.getElementById("realign_to").innerHTML = newAlign;
  
  
  //TODO: apply rules diff
  // make distinct object correct
  allTokens = oldTokens;
  regularize(allRules);
}

function getNullContent()
{
  var content = "null ";
  
  for(var i in allTokens.alignment)
  {
    content += allTokens.alignment[i].witness + " ";
  }
  content += "///";
  return content;
}

function createNewAllTokens()
{
  var newTokens = { alignment: [] };
  
  for(var i in allTokens.alignment)
  {
    newTokens.alignment.push({
      "witness": allTokens.alignment[i].witness,
      "tokens": []
    });
    
    for(var j in allTokens.alignment[i].tokens)
    {
      if(allTokens.alignment[i].tokens[j] == null)
      {
        newTokens.alignment[i].tokens.push(null);
      }
      else
      {
        newTokens.alignment[i].tokens.push({
          "t": allTokens.alignment[i].tokens[j].t
        });
      }
    }
  }
  
  return newTokens;
}

</script>
</head>

<body onload="load()">
  <h1>Collation Interface: for <label for="title_label" id="title_label"></label></h1>
<label for="regularize_label" id="regularize_label">Single click on the word you want regularized, double click or type in the
word you want it regularized to.  <br/>Select combination of Witnesses and Place.  Click OK when finished.</label>
<br /><br /><label for="reg_on" id="reg_on">Regularization is off! (Showing
originals)
</label>

<table>
<tr>
<td>
<form action="." method="POST" name="regularization">
       <br /><textarea rows="10" cols="75" name="reg" onclick="determineClick()"></textarea>
       
       <br /> <input type="checkbox" name="reg_checkbox" value="reg_checkbox" onchange="showRegularization(this)"/>
        Add regularization rules
       <br /> <input type="checkbox" name="change" value="change" onchange="showRealign(this)"/>
        Change alignment of token
       <br />
       
       <input name="reg_on" id="reg_button" type="button" value="Reg. On" onclick="regularize_onoff()">
       <input name="back" type="button" value="Back Entity" onclick="backEntity()">
       <input name="forward" type="button" value="Forward Entity" onclick="forwardEntity()">
       <input name="previous" type="button" value="Previous Word" onclick="previousToken()">
       <input name="next" type="button" value="Next Word" onclick="nextToken()"><br />
    
       <div id="reg_wrapper"></div><br />
       
</form>

  <form name="realign_token" id="realign_token">
    <div id="align_wrapper"></div><br/>
    </form>
</td>
<td valign="top">
  <label id="newRegInfo"></label><br/>
<form action="." method="POST" name="information">
<h2>Witness Information</h2>
Word <label for="word" id="word"></label> in line <label for="line" id="line"></label> in entity <label for="block" id="block"></label>
in witness <label for="witnessId" id="witnessId"></label>

<br /><br />

Context:<br/>
<label for="context" id="context"></label>

<br /><br />

</form>
<form action="." method="POST" name="reg_information">
Regularization from:<br/>
<label for="reg_this_info" id="reg_this_info"></label>

<br /><br />

Regularization to:<br/>
<label for="reg_to_info" id="reg_to_info"></label>

<br /><br />

This regularization set for <label for="choice" id="choice"></label>
</form>
</td>
</tr>

<tr>
  <td>
<form name="edit_reg">
<h2>Regularizations</h2>

<table id="reg_table" border="1">
	
</table>

<input name="submit" type="button" value="Submit" onclick="submitCustomReg()">

</form>
  </td>
</tr>
</table>
</body> </html>
