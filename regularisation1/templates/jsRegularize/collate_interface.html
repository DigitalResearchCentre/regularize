<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>Collate Interface</title>
<script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
<script type="text/javascript" src="http://maps.google.com/maps/api/js?libraries=geometry&sensor=false"></script>
<script type="text/javascript">
  
  var userName = "{{ userName }}";
  var urn = "{{ urn }}";
  var ruleSetName = "{{ ruleSetName }}";
  var witnessDataTokens = (("{{ witnessesTokens}}")).replace(/&(l|g|quo)t;/g, function(a,b)
  {
    return {
      l : '<',
      g : '>',
      quo : '"'
    }[b];
  });
  var witnessDataLines = (("{{ witnessesLines}}")).replace(/&(l|g|quo)t;/g, function(a,b)
  {
    return {
      l : '<',
      g : '>',
      quo : '"'
    }[b];
  });
  var ruleSet = (("{{ ruleSet }}")).replace(/&(l|g|quo)t;/g, function(a,b)
  {
    return {
      l : '<',
      g : '>',
      quo : '"'
    }[b];
  });
  var allImages = (("{{ images }}")).replace(/&(l|g|quo)t;/g, function(a,b)
  {
    return {
      l : '<',
      g : '>',
      quo : '"'
    }[b];
  });

var allWitnesses;
var newRules;
var contextStruct;
var allTokens;
var totalPos;
var currentPosition = "{{ position }}";
var regOn;
var iTimeoutId = null;
var allRules;
var reg_thisBox;
var reg_toBox;
var origTokens;
var isBuildWitnesses;
var isRecollate;
var customRules;
var isCustomRules;
var autoReg;
var distinct;
var changeLabelTimer = null;
var isOriginals;
var isRealign;
var alignOn;
var allAlign;
var customAligns;
var isCustomAlign;
var map;

function load()
{
  witnessDataTokens = witnessDataTokens.replace(/u'/g, '\'');
  witnessDataTokens = witnessDataTokens.replace(/'/g, '\"');
  witnessDataTokens = JSON.parse(witnessDataTokens);

  witnessDataLines = witnessDataLines.replace(/u'/g, '\'');
  witnessDataLines = witnessDataLines.replace(/'/g, '\"');
  witnessDataLines = JSON.parse(witnessDataLines);
  
  ruleSet = ruleSet.replace(/u'/g, '\'');
  ruleSet = ruleSet.replace(/'/g, '\"');
  ruleSet = JSON.parse(ruleSet);
  
  allImages = allImages.replace(/u'/g, '\'');
  allImages = allImages.replace(/'/g, '\"');
  allImages = JSON.parse(allImages);
  //console.log(allImages);
  
  var temp = urn.split("entity=")[1];
  var entity = temp.split(":", 1)[0];
  var line = temp.split("Line=")[1];
  document.getElementById("title_label").innerHTML = "entity " + entity + ", line " + line;
  
  document.information.style.visibility = "hidden";
  document.reg_information.style.visibility ="hidden";
  document.edit_reg.style.visibility = "hidden";
  document.regularization.reg_checkbox.checked = true;
  
  alignOn = false;
  isOriginals = false;
  isRealign = false;
  newRules = { rules: [] };
  customRules = { rules: [] };
  customAligns = { alignments: [] };
  isCustomAlign = false;
  allRules = { rules: [] };
  allAlign = { alignments: [] };
  for(var i in ruleSet.ruleSet.rules)
  {
    allRules.rules.push(ruleSet.ruleSet.rules[i]);
  }
  for(var i in ruleSet.ruleSet.alignments)
  {
    allAlign.alignments.push(ruleSet.ruleSet.alignments[i]);
  }
  contextStruct = { witnesses: [] };
  
  isBuildWitnesses = false;
  isRecollate = false;
  isCustomRules = false;
  autoReg = false;
  distinct = { witnesses: [] };
  
   // add keyboard shortcut
  shortcut.add("Alt+Right", function () {
    addTokenThis();
  });

  shortcut.add("Shift+Right", function () {
    if(!isRealign)
    {
      addTokenTo();
    }
  });

  shortcut.add("Tab", function() {
    if(!isRealign)
    {
      findNextVariant();
    }
  });
  
  shortcut.add("Enter", function() {
    if(!isRealign)
    {
      addRule();
    }
  });
    
  allTokens = witnessDataTokens;
  origTokens = createNewAllTokens();
  allWitnesses = witnessDataLines;
  console.log(allTokens);
  
  totalPos = allTokens.alignment[0].tokens.length;
  
  showRegularization(document.regularization.reg_checkbox);
  regOn = false;
  regularize_onoff();
  regularize();
}

function nextToken()
{
  var reg_toWhole = document.regularization.reg_to.value;
  document.regularization.reg_this.value = "";

  if(!regOn)
  {
    allTokens = origTokens;
  }
  
  if(currentPosition != totalPos)
  {
    currentPosition++;
  }
  
  regularize();
  
  document.regularization.reg_to.value = reg_toWhole;
  
  //console.log(allTokens);
}

function previousToken()
{
  var reg_toWhole = document.regularization.reg_to.value;
  document.regularization.reg_this.value = "";
  
  if(!regOn)
  {
    allTokens = origTokens;
  }

  if(currentPosition != 0)
  {
    currentPosition--;
  }
  
  regularize();
 
  
  document.regularization.reg_to.value = reg_toWhole;
  
  //console.log(allTokens);
}

function determineClick()
{
  if(!isRealign)
  {
    if (iTimeoutId == null || !iTimeoutId)
    {
      iTimeoutId = setTimeout("selectToken()", 500);
    }
    else
    {
      //window.clearTimeout(iTimeoutId);
      clearTimeout(iTimeoutId);
      iTimeoutId = null;
      selectNew();
    }
  }
  else
  {
    selectRealignToken();
  }
}

function selectRealignToken()
{
  var content = document.regularization.reg.value;
  var txt = document.regularization.reg;
  var pos = txt.selectionStart;
  if(document.getElementById("move_realign").checked)
  {
    document.getElementById("backward_realign").checked = false;
    document.getElementById("forward_realign").checked = false;
    document.getElementById("backward_select").style.visibility = "hidden";
    document.getElementById("forward_select").style.visibility = "hidden";
  }

  var token = findWord(pos, content);

  if(!token)
  {
    alert("Invalid selection");
  }
  else if(token != "isId")
  {
    document.realign_token.token.value = token;
  }
}

function findWord(pos, content)
{
  //find whitespaces -- find word indexes
    var found = false;
    var endPos = pos;
    while(!found)
    {
      if(content[endPos] != " ")
      {
        endPos++;
      }
      else
      {
        found = true;
      }
    }

    found = false;
    var startPos = pos;
    while(!found)
    {
      if(content[startPos] != " ")
      {
        if(startPos != 0)
        {
          startPos--;
        }
        else
        {
          found = true;
        }
      }
      else
      {
        found = true;
      }
    }

  var length = endPos - startPos;
  var token = content.substr(startPos, length);
  token = token.split(" ");
  token = token.join("");
  var origToken = token;
  token = token.split("(")[0];
  if(isOriginals)
  {
    token = token.split(",")[0];
  }

  var notToken = false;
  var isId = false;
  for(var i in allWitnesses.witnesses)
  {
    if(token == allWitnesses.witnesses[i].id)
    {
      informationWindow(allWitnesses.witnesses[i].id);
      isId = true;
      token = "isId";
    }
  }
  
  if(!isId)
  {
    token = origToken;
  }

  if(token == "///" || token == "" || token == "null")
  {
    notToken = true;
  }

  if(notToken)
  {
    return false;
  }
  else
  {
    return token;
  }
}

function selectToken()
{
    window.clearTimeout(iTimeoutId);
    iTimeoutId = null;
    
    var content = document.regularization.reg.value;
    var txt = document.regularization.reg;
    var pos = txt.selectionStart;

    var token = findWord(pos, content);

    if(!token)
    {
      alert("Invalid selection");
    }
    else if(token != "isId")
    {
      document.regularization.reg_this.value = token;
      reg_thisBox = token;
    }

}

function selectNew()
{
  window.clearTimeout(iTimeoutId);
  iTimeoutId = null;
  var content = document.regularization.reg.value;
  var txt = document.regularization.reg;
  var pos = txt.selectionStart;

  token = findWord(pos, content);

  if(!token)
  {
    alert("Invalid selection");
  }
  else if(token != "isId")
  {
    document.regularization.reg_to.value = token;
    reg_toBox = token;
  }
}

function addRule()
{
  
  var reg_thisWhole = document.regularization.reg_this.value;
  var reg_toWhole = document.regularization.reg_to.value;
    
  if(regOn && reg_thisWhole != reg_toWhole)
  {
    var reg_word = reg_thisBox;
    var reg_to = reg_toBox;
    var reg_thisWhole = document.regularization.reg_this.value;
    var reg_toWhole = document.regularization.reg_to.value;
    var choice = document.regularization.reg_choices.value;
    var newRule = "";
    var index = "";
    var rulesToAdd = {rules:[]};

    if(reg_thisWhole == "" || reg_toWhole == "")
    {
      alert("Invalid Rule");
      return false;
    }

    if(reg_toWhole[reg_toWhole.length] == " ")
    {
      reg_toWhole = reg_toWhole.substring(0, reg_toWhole.length-1);
    }

    if (reg_word != "" && reg_to != "")
    {
      if(choice == "this_place")
      {
        for (var i in distinct.witnesses)
        {
          if(reg_word == distinct.witnesses[i].token)
          {
             index = i;
          }
        }

        // get rule for each of the witnesses with this token
        for(var i in distinct.witnesses[index].originals)
        {
          for(var j in distinct.witnesses[index].originals[i].id)
          {
            var id = distinct.witnesses[index].originals[i].id[j];
            newRule = createRule(choice, reg_thisWhole, reg_toWhole, reg_word, id, index);

            var add = true;
            for(var i in rulesToAdd.rules)
            {
              if(rulesToAdd.rules[i].scope == newRule.scope && rulesToAdd.rules[i].action == newRule.action && 
                  rulesToAdd.rules[i].token == newRule.token)
              {
                add = false;
              }
            }

            if(add)
            {
              rulesToAdd.rules.push(newRule);
            }
          }
        }

        for(var i in rulesToAdd.rules)
        {
          addRuleList(rulesToAdd.rules[i]);
        }
      }
      else
      {
        newRule = createRule(choice, reg_thisWhole, reg_toWhole, reg_word, "", "");
        addRuleList(newRule);
      }

    }
    
    //console.log(contextStruct);

    contextStruct = { witnesses: [] };

    document.regularization.reg_this.value = "";
    document.regularization.reg_to.value = reg_toWhole;

    if(regOn)
    {
      insertRegTable(choice, reg_thisWhole, reg_toWhole);
    }

    changeRegularizeLabel(choice, reg_thisWhole, reg_toWhole);
  }
  else
  {
    alert("Turn regularization on to add new rules");
  }
}

function addRuleList(newRule)
{ 
  sendRule(newRule);
  
  if(isCustomRules)
  {
    customRules.rules.push(newRule);
    allRules.rules.push(newRule);
    regularize();
    //);
  }
  else //if(regOn && !isCustomRules)
  {
    allRules.rules.push(newRule);
    regularize();
    //);
  }

}

/*
 * id: id of the witness getting context for
 * index: index in the distinct.witnesses list (for token)
 */
function getContext(id, index)
{   
  var needMoreContext = false;
  var context = "";
  var contextIndex;
  var origContext = "";
  
  // find the context that relate to the id
  for(var i in contextStruct.witnesses)
  {
    if(contextStruct.witnesses[i].id == id)
    {
      context = contextStruct.witnesses[i].context;
      origContext = contextStruct.witnesses[i].context;
      context = context.split(/\W/);
      context = context.join(' ');
      contextIndex = i;
    }
  }
  var re = new RegExp(context, 'g');
  
  // find if the context matches any witnesses
  // if it matches any witnesses that are not to be 
  // regularize --> needMoreContext
  // if there are more than one match in a witness to 
  // be regularized --> needMoreContext
  for(var i in allWitnesses.witnesses)
  {
    var witness = allWitnesses.witnesses[i].content.split(/\W/).join(' ');
    var result = witness.match(re);
    var isId = false;
    
    if(result)
    {
      for(var j in distinct.witnesses[index].originals)
      {
        for(var k in distinct.witnesses[index].originals[j].id)
        {
          var dWid = distinct.witnesses[index].originals[j].id[k];
          if(dWid == allWitnesses.witnesses[i].id)
          {
            isId = true;
            if(result.length > 1)
            {
              needMoreContext = true;
            }
          }
        }
      }
      
      if(!isId)
      {
        needMoreContext = true;
      }
    }
  }
  
  if(needMoreContext)
  {
    returnContext = getMoreContext(id, index, contextIndex);
    if(returnContext)
    {
      return context = getContext(id, index);
    }
    else
    {
      return origContext;
    }
  }
  else
  {
    return origContext;
  }
  
}

/*
 * id: id of the witness getting context for
 * index: index in the distinct.witnesses list (for token)
 * witnessIndex: index into the contextStruct
 */
function getMoreContext(id, index, witnessIndex)
{
  //alert("getMoreContext");
  
  var tokenWitnessIndex;
  for (var i in allWitnesses.witnesses)
  {
    if(allWitnesses.witnesses[i].id == id)
    {
      tokenWitnessIndex = i;
    }
  }

  if(contextStruct.witnesses[witnessIndex].startPos == 1 && contextStruct.witnesses[witnessIndex].maxPos == totalPos)
  {
    // total context
    return false;
  }
  else if (contextStruct.witnesses[witnessIndex].startPos == 1 && contextStruct.witnesses[witnessIndex].endPos != totalPos)
  {
    contextStruct.witnesses[witnessIndex].endPos++;
    if(allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].endPos] != null)
    {
      contextStruct.witnesses[witnessIndex].context += " " + allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].endPos].t;
    }
    contextStruct.witnesses[witnessIndex].switchDirections = false;
  }
  else if (contextStruct.witnesses[witnessIndex].endPos == totalPos && contextStruct.witnesses[witnessIndex].startPos != 1)
  {
    contextStruct.witnesses[witnessIndex].startPos--;
    if(allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].startPos] != null)
    {
      contextStruct.witnesses[witnessIndex].context = allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].startPos].t + " " + contextStruct.witnesses[witnessIndex].context;
    }
    contextStruct.witnesses[witnessIndex].switchDirections = false;
  }
  else if (contextStruct.witnesses[witnessIndex].goForward == true && contextStruct.witnesses[witnessIndex].endPos != totalPos)
  {
    contextStruct.witnesses[witnessIndex].goForward = false;
    contextStruct.witnesses[witnessIndex].endPos++;
    if(allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].endPos] != null)
    {
      contextStruct.witnesses[witnessIndex].context += " " + allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].endPos].t;
    }
  }
  else if (contextStruct.witnesses[witnessIndex].goForward == false && contextStruct.witnesses[witnessIndex].startPos != 1)
  {
    contextStruct.witnesses[witnessIndex].goForward = true;
    contextStruct.witnesses[witnessIndex].startPos--;
    if(allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].startPos] != null)
    {
      contextStruct.witnesses[witnessIndex].context = allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].startPos].t + " " + contextStruct.witnesses[witnessIndex].context;
    }
  }

  return true;
}

function sendRule(newRule)
{
  var sendRules = {rules: []};
  sendRules.rules.push(newRule);
  sendRules.urn = urn;
  sendRules.userName = userName;
  sendRules.ruleSetName = ruleSetName;
  
    $.post("http://127.0.0.1:8000/regularization/postNewRule/",
       JSON.stringify(sendRules), function(data){
       //alert("success");
     })
   .error(function () {alert("error: saveRules");})

}

function changeRegularizeLabel(choice, reg_thisWhole, reg_toWhole)
{
  
  changeLabelTimer = null;
  
  var scope = "";
  if(choice == "all_places")
  {
    scope = "all places in all witnesses.";
  }
  else if (choice == "this_entity")
  {
    scope = "all witnesses in this entity.";
  }
  else
  {
    scope = "all witnesses for this place.";
  }
  
  var content = "REGULARIZED:: \"" + reg_thisWhole + "\" to \"" + reg_toWhole + "\" in " + scope + "</br>";
  document.getElementById('newRegInfo').innerHTML = content;
  
  if (changeLabelTimer == null || !changeLabelTimer)
  {
    changeLabelTimer = setTimeout(function() {document.getElementById('newRegInfo').innerHTML = "";}, 5000);
  }
  
}

function regularize_onoff()
{
  
  if (regOn == false)
  {
     if(document.regularization.reg_checkbox.checked)
     {
       document.regularization.originals.style.visibility = "visible";
       document.getElementById("showOriginals").style.visibility = "visible";
       document.getElementById("showOriginals").innerHTML = "Show originals";
       document.regularization.automate.style.visibility = "visible";
       document.getElementById("automateLabel").style.visibility = "visible";
       document.getElementById("automateLabel").innerHTML = "Automate regularization"
       document.edit_reg.style.visibility = "hidden";
     }
     regOn = true;
     document.getElementById('reg_on').innerHTML = "Regularization is on! Click on a witness for a regularized word to see more detail.";
     document.getElementById('reg_button').value = "Reg. Off";

     if(!alignOn)
     {
       loadRegTable();
     }
     regularize();
  }
  else
  {
     if(document.regularization.reg_checkbox.checked)
     {
       document.regularization.originals.style.visibility = "hidden";
       document.getElementById("showOriginals").style.visibility = "hidden";
       document.regularization.automate.style.visibility = "hidden";
       document.getElementById("automateLabel").style.visibility = "hidden";
     }
     
     regOn = false;
     string = "Regularization is off! (Showing originals)";
     document.getElementById('reg_on').innerHTML = string;
     document.getElementById('reg_button').value = "Reg. On";
     
     //document.information.style.visibility = "hidden";
     document.edit_reg.style.visibility = "hidden";
     
     allTokens = getBaseTokens();
     // should applyAlign if alignOn
     regularize();
     
     
     //);
  }
  
}

function regularize()
{

  var position = currentPosition;
  
  var content = findDistinct(position);
  
  if(!isRealign)
  {
    automateReg(document.getElementById("automate"));
  }

  document.regularization.reg.value = content;
  
}

function findDistinct(position)
{
  if(!regOn)
  {
    regRules = newRules;
  }
  else if(isCustomRules)
  {
    regRules = customRules;
  }
  else
  {
    regRules = allRules;
  }
  
  distinct = {witnesses:[]};
  
  for (var i in allTokens.alignment)
  {
    var regToken = false;
    var origToken = "";
    var added = false;
    var token = "";

    // get token from json
    if(allTokens.alignment[i].tokens[position] == null)
    {
       origToken = "null";
    }
    else
    {
      origToken = allTokens.alignment[i].tokens[position].t;
    }

    // regularize token
    var token = getToken(i, position);
    

    // determine what the original token is, if it is regularized
    if(origToken != token)
    {
      regToken=true;
    }
    
    if(allTokens.alignment[i].tokens[position] != null)
    {
      if(allTokens.alignment[i].tokens[position].origToken != "" && allTokens.alignment[i].tokens[position].origToken != undefined)
      {
        regToken = true;
        origToken = allTokens.alignment[i].tokens[position].origToken;
      }
    }
    
    // search if token is already in the array
    // if is ... add after
    for(var j in distinct.witnesses)
    {
      var distinctToken = distinct.witnesses[j].token;
      
      if(token == distinctToken && !added)
      {
        for( var k in distinct.witnesses[j].originals)
        {
          //console.log(distinct);
          if(origToken == distinct.witnesses[j].originals[k].origToken && !added)
          {
            distinct.witnesses[j].originals[k].id.push(allTokens.alignment[i].witness);
            added = true;
          }
        }
        if(!added)
        {
          distinct.witnesses[j].originals.push({
            "origToken": origToken,
            "id": []
          });
          
          var index = distinct.witnesses[j].originals.length-1;
          distinct.witnesses[j].originals[index].id.push(allTokens.alignment[i].witness);
          added = true;
        }
      }
    }
    
    // add token to array because it is the first one
    if(i==0)
    {
      distinct.witnesses.push({
        "token": token,
        "originals": []
      });
      
      distinct.witnesses[i].originals.push({
        "origToken": origToken,
        "id" : []
      });
      
      distinct.witnesses[i].originals[i].id.push(allTokens.alignment[i].witness);
      added = true;
    }
    // not already in array ... add token and id to it
    else if (!added)
    {
      distinct.witnesses.push({
        "token": token,
        "originals": []
      });
      
      for(var j in distinct.witnesses)
      {
        if(distinct.witnesses[j].token == token && !added)
        {
          distinct.witnesses[j].originals.push({
            "origToken": origToken,
            "id" : []
          });
          
          var index = distinct.witnesses[j].originals.length-1;
          distinct.witnesses[j].originals[index].id.push(allTokens.alignment[i].witness);
        }
      }
    }
  }
  
  // create the content for the collation area text box
  var content = "";
  for (var i in distinct.witnesses)
  {
    content += distinct.witnesses[i].token;
    
    for(var j in distinct.witnesses[i].originals)
    {
      if(distinct.witnesses[i].originals[j].origToken != distinct.witnesses[i].token && isOriginals)
      {
        for(var k in distinct.witnesses[i].originals[j].id)
        {
          content += " " + distinct.witnesses[i].originals[j].id[k];
        }

        content += "(" + distinct.witnesses[i].originals[j].origToken + "), ";
      }
      else
      {
        for(var k in distinct.witnesses[i].originals[j].id)
        {
          content += " " + distinct.witnesses[i].originals[j].id[k];
        }
        if(isOriginals)
        {
          content += ",";
        }
      }
    }
    
    content += " /// "; 
  }
 
  return content;
  
}

//http://www.openjs.com/scripts/events/keyboard_shortcuts/
shortcut = {
	'all_shortcuts':{},//All the shortcuts are stored in this array
	'add': function(shortcut_combination,callback,opt) {
		//Provide a set of default options
		var default_options = {
			'type':'keydown',
			'propagate':false,
			'disable_in_input':false,
			'target':document,
			'keycode':false
		}
		if(!opt) opt = default_options;
		else {
			for(var dfo in default_options) {
				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
			}
		}

		var ele = opt.target;
		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
		var ths = this;
		shortcut_combination = shortcut_combination.toLowerCase();

		//The function to be called at keypress
		var func = function(e) {
			e = e || window.event;
			
			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
				var element;
				if(e.target) element=e.target;
				else if(e.srcElement) element=e.srcElement;
				if(element.nodeType==3) element=element.parentNode;

				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
			}
	
			//Find Which key is pressed
			if (e.keyCode) code = e.keyCode;
			else if (e.which) code = e.which;
			var character = String.fromCharCode(code).toLowerCase();
			
			if(code == 188) character=","; //If the user presses , when the type is onkeydown
			if(code == 190) character="."; //If the user presses , when the type is onkeydown

			var keys = shortcut_combination.split("+");
			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
			var kp = 0;
			
			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
			var shift_nums = {
				"`":"~",
				"1":"!",
				"2":"@",
				"3":"#",
				"4":"$",
				"5":"%",
				"6":"^",
				"7":"&",
				"8":"*",
				"9":"(",
				"0":")",
				"-":"_",
				"=":"+",
				";":":",
				"'":"\"",
				",":"<",
				".":">",
				"/":"?",
				"\\":"|"
			}
			//Special Keys - and their codes
			var special_keys = {
				'esc':27,
				'escape':27,
				'tab':9,
				'space':32,
				'return':13,
				'enter':13,
				'backspace':8,
	
				'scrolllock':145,
				'scroll_lock':145,
				'scroll':145,
				'capslock':20,
				'caps_lock':20,
				'caps':20,
				'numlock':144,
				'num_lock':144,
				'num':144,
				
				'pause':19,
				'break':19,
				
				'insert':45,
				'home':36,
				'delete':46,
				'end':35,
				
				'pageup':33,
				'page_up':33,
				'pu':33,
	
				'pagedown':34,
				'page_down':34,
				'pd':34,
	
				'left':37,
				'up':38,
				'right':39,
				'down':40,
	
				'f1':112,
				'f2':113,
				'f3':114,
				'f4':115,
				'f5':116,
				'f6':117,
				'f7':118,
				'f8':119,
				'f9':120,
				'f10':121,
				'f11':122,
				'f12':123
			}
	
			var modifiers = { 
				shift: { wanted:false, pressed:false},
				ctrl : { wanted:false, pressed:false},
				alt  : { wanted:false, pressed:false},
				meta : { wanted:false, pressed:false}	//Meta is Mac specific
			};
                        
			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
			if(e.shiftKey)	modifiers.shift.pressed = true;
			if(e.altKey)	modifiers.alt.pressed = true;
			if(e.metaKey)   modifiers.meta.pressed = true;
                        
			for(var i=0; k=keys[i],i<keys.length; i++) {
				//Modifiers
				if(k == 'ctrl' || k == 'control') {
					kp++;
					modifiers.ctrl.wanted = true;

				} else if(k == 'shift') {
					kp++;
					modifiers.shift.wanted = true;

				} else if(k == 'alt') {
					kp++;
					modifiers.alt.wanted = true;
				} else if(k == 'meta') {
					kp++;
					modifiers.meta.wanted = true;
				} else if(k.length > 1) { //If it is a special key
					if(special_keys[k] == code) kp++;
					
				} else if(opt['keycode']) {
					if(opt['keycode'] == code) kp++;

				} else { //The special keys did not match
					if(character == k) kp++;
					else {
						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
							character = shift_nums[character]; 
							if(character == k) kp++;
						}
					}
				}
			}
			
			if(kp == keys.length && 
						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
						modifiers.shift.pressed == modifiers.shift.wanted &&
						modifiers.alt.pressed == modifiers.alt.wanted &&
						modifiers.meta.pressed == modifiers.meta.wanted) {
				callback(e);
	
				if(!opt['propagate']) { //Stop the event
					//e.cancelBubble is supported by IE - this will kill the bubbling process.
					e.cancelBubble = true;
					e.returnValue = false;
	
					//e.stopPropagation works in Firefox.
					if (e.stopPropagation) {
						e.stopPropagation();
						e.preventDefault();
					}
					return false;
				}
			}
		}
		this.all_shortcuts[shortcut_combination] = {
			'callback':func, 
			'target':ele, 
			'event': opt['type']
		};
		//Attach the function with the event
		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
		else ele['on'+opt['type']] = func;
	},

//Remove the shortcut - just specify the shortcut and I will remove the binding
	'remove':function(shortcut_combination) {
		shortcut_combination = shortcut_combination.toLowerCase();
		var binding = this.all_shortcuts[shortcut_combination];
		delete(this.all_shortcuts[shortcut_combination])
		if(!binding) return;
		var type = binding['event'];
		var ele = binding['target'];
		var callback = binding['callback'];

		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
		else ele['on'+type] = false;
	}
}

function findNextVariant()
{
  var reg_to = document.regularization.reg_to.value;

  var position = currentPosition;
  
  if(!regOn)
  {
    alert("Regularization must be on to perform this action");
    return;
  }

  if(isCustomRules)
  {
    regRules = customRules;
  }
  else
  {
    regRules = allRules;
  }

  if(reg_to == "")
  {
    alert("Please select a token");
  }
  else
  {
     reg_to = reg_to.split(" ", 1);
     var found = false;
     var foundVariant = false;
     var variant = "";
     for (var i in allTokens.alignment)
     {
       var token = getToken(i, position);

       if (token == reg_to && !found)
       {
         found = true;
       }
       else if (found && reg_to != token && !foundVariant)
       {
           foundVariant = true;
           variant = token;
           reg_thisBox = token;
       }
     }
     if(foundVariant)
     {
       document.regularization.reg_this.value = "";
       document.regularization.reg_this.value = variant;
     }
     else
     {
       alert("Error: Cannot get next variant.");
     } 
   }
}

function addTokenTo()
{
    // if more than one winess, check to see if words are different
    // if words are different -> cannot add next word
    // else add next word to reg_this
    // if reg_on see if rules apply to next word!

  var reg_this = document.regularization.reg_to.value;
  var position = currentPosition;
  var newToken = "";
  
  if(!regOn)
  {
    alert("Regularization must be on to perform this action");
    return;
  }
  
  var reg_thisArray = reg_this.split(" ");
  var newPosition = currentPosition-1;
  newPosition += reg_thisArray.length;

  if(reg_this == "")
  {
    alert("Please select a token");
  }
  else if(newPosition >= totalPos)
  {
    alert("Cannot add next token: There are no more tokens in entity!");
  }
  else
  {
     position--;
     for(var i in reg_thisArray)
     {
       reg_this = reg_thisArray[i];
       position++;
     }
  
     var add = true;
     var found = false;

     for (var i in allTokens.alignment)
     {
       var token = getToken(i, position);
        
        if(token == reg_this)
        {
         var newPosition = position + 1;
         var rToken = getToken(i, newPosition);

          if(!found)
          {
           	found = true;
           	newToken = rToken;
          }
          else if(found && rToken != newToken)
          {
            add = false;
          }
         }
    }

     if(add)
     {
       document.regularization.reg_to.value += " " + newToken;
     }
     else
     {
       alert("Error: Cannot get next token.  Not all next tokens match.");
     } 
  }

}

function addTokenThis()
{
    // if more than one winess, check to see if words are different
    // if words are different -> cannot add next word
    // else add next word to reg_this
    // if reg_on see if rules apply to next word!

  
  var reg_this = "";
  if(!isRealign)
  {
    reg_this = document.regularization.reg_this.value;
  }
  else
  {
    reg_this = document.realign_token.token.value;
  }
  var position = currentPosition;
  var newToken = "";
  
  if(!regOn && !isRealign)
  {
    alert("Regularization must be on to perform this action");
    return;
  }
  else if(isRealign && !alignOn)
  {
    alert("Alignment must be on to perform this action");
    return;
  }
  
  var reg_thisArray = reg_this.split(" ");
  var newPosition = currentPosition-1;
  newPosition += reg_thisArray.length;

  if(reg_this == "")
  {
    alert("Please select a token");
  }
  else if(newPosition >= totalPos)
  {
    alert("Cannot add next token: There are no more tokens in entity!");
  }
  else
  {
     position--;
     for(var i in reg_thisArray)
     {
       reg_this = reg_thisArray[i];
       position++;
     }
  
     var add = true;
     var found = false;

     for (var i in allTokens.alignment)
     {
       var token = getToken(i, position);
        
        
        if(token == reg_this)
        {
          var newPosition = position + 1;
          var rToken = getToken(i, newPosition);

          if(!found)
          {
           	found = true;
           	newToken = rToken;
          }
          else if(found && rToken != newToken)
          {
            add = false;
          }
         }
    }

     if(add && !isRealign)
     {
       document.regularization.reg_this.value += " " + newToken;
     }
     else if(add && isRealign)
     {
       document.realign_token.token.value += " " + newToken;
     }
     else
     {
       alert("Error: Cannot get next token.  Not all next tokens match.");
     } 
  }
}

function buildWitnesses()
{
  //alert("buildWitnesses");
  newWitnesses = { witnesses: [] };
  isBuildWitnesses = true;
  allTokens = origTokens;

  for (var i in allTokens.alignment)
  {
    var content = "";
    for (var j in allTokens.alignment[i].tokens)
    {
      var token = getToken(i, j);
      if(token != "null")
      {
        content += token + " ";
      }
    }

    content = content.substring(0, content.length-1);
    newWitnesses.witnesses.push ({
      "id": allTokens.alignment[i].witness,
      "content": content
    });
  }
  
  isBuildWitnesses=false;

  return newWitnesses;
}

function seeWitnesses()
{

  var newWitnesses = buildWitnesses();
  
  var content = "";

  for(var i in newWitnesses.witnesses)
  {
    content += newWitnesses.witnesses[i].id + ": " + newWitnesses.witnesses[i].content + "<br />";
  }
  
  document.getElementById('newRegInfo').innerHTML = content;
  document.getElementById("newRegInfo").style.visibility = "visible";
}

function recollate()
{  
  isRecollate = true;
  //var newWitnesses = buildWitnesses();
  var newWitnesses = createNewAllTokens();
  isRecollate = false;
  newWitnesses = JSON.stringify(newWitnesses);
  
  $.ajax({
    url: "http://127.0.0.1:8000/regularization/postRecollate/",
    dataType: 'json',
    type: 'post',
    async: false,
    data: newWitnesses,
    success: function(data){
    }});
  
  
  $.ajax({
    url: "http://127.0.0.1:8000/regularization/sendRecollate/",
    dataType: 'json',
    async: false,
    success: function(data){
      for(var i in data.alignment)
      {
        for(var j in data.alignment[i].tokens)
        {
            for(var k in allTokens.alignment[i].tokens)
            {
              if(allTokens.alignment[i].tokens[k] != null && data.alignment[i].tokens[j] != null)
              {
                if(allTokens.alignment[i].tokens[k].t == data.alignment[i].tokens[j].t)
                {
                  data.alignment[i].tokens[j].origToken = allTokens.alignment[i].tokens[k].origToken;
                }
              }
            }
        }
      }
      
      allTokens = data;
      
      totalPos = allTokens.alignment[0].tokens.length;
      
 }});
}

function checkSpaces(reg_word)
{
  
  var position = 0;
  var i = -1;
  var indices = [];
  
  while (position != -1)
  {
    position = reg_word.indexOf(" ", i + 1);
    if(position != -1)
    {
      indices.push(position);
    }
    i = position;
  }
  
  if(indices == [])
  {
    return false;
  }
  else
  {
    return indices;
  }
}

function getToken(witnessId, position)
{
   var token = "";
   var collate = false;
   var origToken = "";
   var regRules = { rules: []};
   var foundMatch = true;
   var ruleApplied = false;
   
   if(isCustomRules)
   {
     regRules = customRules;
     
   }
   else
   {
     regRules = allRules;
   }
  
   if(allTokens.alignment[witnessId].tokens[position] == null)
   {
     token = "null";
   }
   else
   {
     token = allTokens.alignment[witnessId].tokens[position].t;
     origToken = allTokens.alignment[witnessId].tokens[position].t;
   }

   for (var k in regRules.rules)
   {
     var action = regRules.rules[k].action;
     var reg_this = action.split(',')[0];
     reg_this = reg_this.substring(11,reg_this.length);
     var reg_to = action.split(', ')[1];
     reg_to = reg_to.substring(0, reg_to.length-1);
     var wholeToToken = reg_to;
     var regularizeToken = regRules.rules[k].token;
     var choice = regRules.rules[k].scope;
     foundMatch = true;
     var modifications = regRules.rules[k].modifications;
     if (modifications[modifications.length-1].modification_type == "delete")
     {
       isDisabled = true;
     }
     else if (token == regRules.rules[k].token)
     {  
        if(choice == "this_place")
        {
          //alert(allTokens.alignment[witnessId].witness);
          //alert(regularizeToken);
          //alert(reg_this + "; " + reg_to);
          //alert("ruleApplied: " + ruleApplied);
          //console.log(allTokens);
          var reg_thisArray = reg_this.split(" ");
          var reg_toArray = reg_to.split(" ");
          var tokenArray = regularizeToken.split(" ");  //?!? maybe should use reg_thisArray (is token only one word)
          var index = "";
          
          // Establish this is the correct place to regularize
          if(tokenArray.length == 1)
          {
            for(var m in reg_thisArray)
            {
              if(token == reg_thisArray[m])
              {
                index = m;
              }
            }
          }
          else
          {
            for(var m in reg_thisArray)
            {
              if(tokenArray[0] == reg_thisArray[m])
              {
                index = m;
              }
            }
          }
          
          var numBack = currentPosition - index;
          for(var m = 0; m<index; m++)
          {
            //alert(numBack);
            if(allTokens.alignment[witnessId].tokens[numBack] != null)
            {
              if(allTokens.alignment[witnessId].tokens[numBack].t != reg_thisArray[m] && foundMatch)
              {
                //alert("Backward: noMatch");
                //var newTokenn = allTokens.alignment[witnessId].tokens[position].t;
                //alert(newTokenn + " " + reg_thisArray[m]);
                foundMatch = false;
              }
            }
            else
            {
              m--;
            }
            numBack--;
          }
          
          var numForward = currentPosition;
          for(var m = index + tokenArray.length - 1; m < reg_thisArray.length; m++)
          {
            if(allTokens.alignment[witnessId].tokens[numForward] != null)
            {
              if(allTokens.alignment[witnessId].tokens[numForward].t != reg_thisArray[m] && foundMatch)
              {
                //alert(" Forward: noMatch");
                //alert(allTokens.alignment[witnessId].tokens[numForward].t + " " + reg_thisArray[m]);
                foundMatch = false;
              }
            }
            else
            {
              m++;
            }
            numForward++;
          }
          
          if(foundMatch)
          { 
             ruleApplied = true;
             //alert("match");
             var found = false;
             var indexEndThis = 0;
             for(var m = index; m < reg_thisArray; m++)
             {
               for(var n = index; n < reg_toArray; n++)
               {
                 if(reg_thisArray[m] == reg_toArray[n] && !found)
                 {
                   found = true;
                   indexEndThis = m;
                 }
               }
             }
             var endIndex = reg_thisArray.length-index-indexEndThis;
             reg_thisArray = reg_thisArray.splice(index, endIndex);
             
             var indexEndThis = 0;
             for(var m = index; m < reg_thisArray; m++)
             {
               for(var n = index; n < reg_toArray; n++)
               {
                 if(reg_thisArray[m] == reg_toArray[n] && !found)
                 {
                   found = true;
                   indexEndThis = m;
                 }
               }
             }
             reg_thisArray = reg_thisArray.splice(indexEndThis, reg_thisArray.length-1-indexEndThis);
             reg_this = reg_thisArray.join(" ");
             //alert("RegSoFar: " + reg_thisArray.join(" "));
             
             
             for(var m = index; m < reg_toArray; m++)
             {
               for(var n = index; n < reg_thisArray; n++)
               {
                 if(reg_thisArray[n] == reg_toArray[m] && !found)
                 {
                   found = true;
                   indexEndThis = m;
                 }
               }
             }
             reg_toArray = reg_toArray.splice(index, reg_toArray.length-index-indexEndThis);
             
             for(var m = index; m < reg_toArray; m++)
             {
               for(var n = index; n < reg_thisArray; n++)
               {
                 if(reg_thisArray[n] == reg_toArray[m] && !found)
                 {
                   found = true;
                   indexEndThis = m;
                 }
               }
             }
             reg_toArray = reg_toArray.splice(indexEndThis, reg_toArray.length-1-indexEndThis);
             reg_to = reg_toArray.join(" ");
             wholeToToken = reg_to;
             
             //alert("reg_this: " + reg_this + " reg_to: " + reg_to);
            
          }
          else if(!ruleApplied)
          {
            token = origToken;
            //alert("Nomatch: " + token);
          }
          
        }
        
        var spacesThis = checkSpaces(reg_this);
        var spacesTo = checkSpaces(reg_to);
        
        if(spacesThis != false)
        {
            var content = token;

            for (var i in spacesThis)
            {
              position++;
              if(allTokens.alignment[witnessId].tokens[position] == null)
              {
                newToken = "null";
              }
              else
              {
                newToken = allTokens.alignment[witnessId].tokens[position].t;
              }
              content += " " + newToken;
            }

            if(content == reg_this)
            {
              position = currentPosition;
              if(origToken == "")
              {
                origToken = reg_this;
              }
              allTokens.alignment[witnessId].tokens[position].t = reg_to;
              allTokens.alignment[witnessId].tokens[currentPosition].origToken = origToken;
              allTokens.alignment[witnessId].tokens[currentPosition].reg_to = reg_to;

              //console.log(allTokens);
              position++;
              for(var k in spacesThis)
              { 
                allTokens.alignment[witnessId].tokens.splice(position, 1);
              }
              collate = true;
            }
		  
        }
        else
        {
          ///TODO: change in object
          if(foundMatch)
          {
            token = reg_to;
          }
          else
          {
            token = origToken;
          }
        }
        
        if(spacesTo != false && !isBuildWitnesses)
        {
            //Check if next word(s) match
            // if match -> recollate

            var content = reg_to;
            //alert("spacesTo");

            content = content.split(' ').join('');

            //alert(content + " " + reg_this + " " + reg_to);

            if(content == reg_this)
            {
              var insertTokens = reg_to.split(' ');
              var position = currentPosition;
              for(var k in insertTokens)
              {
                if(k == 0)
                {
                  if(origToken == "")
                  {
                    origToken = reg_this;
                  }
                  
                  if(allTokens.alignment[witnessId].tokens[position] != null)
                  {
                    allTokens.alignment[witnessId].tokens[position].t = insertTokens[k];
                    allTokens.alignment[witnessId].tokens[position].origToken = origToken;
                    allTokens.alignment[witnessId].tokens[position].reg_to = reg_to;
                  }
                  else
                  {
                    var insertTok = { "t" : insertTokens[k], "n" : insertTokens[k], "origToken" : origToken, "reg_to" : reg_to};
                    allTokens.alignment[witnessId].tokens.splice(position,1,insertTok);
                    // TODO:: May have to add a null token at end of each other witness to make same number of tokens
                  }
                }
                else
                {
                  if(origToken == "")
                  {
                    origToken = reg_this;
                  }
                  var insertTok = { "t" : insertTokens[k], "n" : insertTokens[k], "origToken" : origToken, "reg_to" : reg_to};
                  allTokens.alignment[witnessId].tokens.splice(position,0,insertTok);
                  // TODO:: May have to add a null token at tend of each oter witness to make same number of tokens
                }
                position++;
              }

              reg_to = reg_to.split(' ')[0];
              collate = true;
              token = reg_to;

            }
        }
        else if(spacesTo != false && isBuildWitnesses)
        {
          token = wholeToToken;
        }
        else
        {
          ///TODO: change in array
          if(foundMatch)
          {
            reg_to = reg_to.split(' ')[0];
            token = reg_to;
          }
          else
          {
            token = origToken;
          }
        }
      }
   }
    
    if(collate)
    {
      collate = false;
      if(!isBuildWitnesses)
      {
      	//recollate();
      	isRecollate = false;
        reg_to = reg_to.split(' ')[0];
      	token = reg_to;
      }
    }
    
    return token;
}

function informationWindow(witnessId)
{
  var regInfo = { data: [] };
  var context = "";
  var index = "";
  var position = currentPosition;
  var regRules = "";
  var token = "";
  var temp = urn.split("entity=")[1];
  var entity = temp.split(":", 1)[0];
  var line = temp.split("Line=")[1];
  
  document.getElementById('newRegInfo').style.visibility = "hidden";
  document.getElementById('newRegInfo').innerHTML = "";
  
  witnessId = witnessId.split('(')[0];
  
  for (var i in allWitnesses.witnesses)
  {
    if(witnessId == allWitnesses.witnesses[i].id)
    {
      context = allWitnesses.witnesses[i].content;
      index = i;
    }
  }
  
  if(isCustomRules && regOn)
  {
    regRules = customRules;
  }
  else if(regOn)
  {
    regRules = allRules;
  }
  else
  {
    regRules = {rules: []};
  }
  
  var reg_this = "";
  var reg_to = "";
  var choice = "";
  
  console.log(distinct);
  for(var j in distinct.witnesses)
  {
    for(var k in distinct.witnesses[j].originals)
    {
      for(var l in distinct.witnesses[j].originals[k].id)
      {
        if(distinct.witnesses[j].originals[k].id[l] == witnessId)
        {
          reg_this = distinct.witnesses[j].originals[k].origToken;
          reg_to = distinct.witnesses[j].token;
        }
      }
    }
  }
  
  if(reg_this != reg_to)
  {
    for(var i in regRules.rules)
    {
      if(reg_this == regRules.rules[i].token)
      {
        choice = regRules.rules[i].scope;
      }
    }
  }
  
  if(choice == "all_places")
  {
    choice = "all places in all witnesses";
  }
  else if(choice == "this_entity")
  {
    choice = "this entity in all witnesses";
  }
  else if(choice == "this_place")
  {
    choice = "this place in all witnesses";
  }
  
  document.information.style.visibility = "visible";
  document.reg_information.style.visibility ="hidden";
  document.getElementById('witnessId').innerHTML = witnessId;
  document.getElementById('word').innerHTML = position;
  document.getElementById('line').innerHTML = line;
  document.getElementById('block').innerHTML = entity; 
  document.getElementById('context').innerHTML = context;
  
  if(reg_this != "" && reg_to != "" && choice != "")
  {
    document.reg_information.style.visibility = "visible";
    document.getElementById('reg_this_info').innerHTML = reg_this;
    document.getElementById('reg_to_info').innerHTML = reg_to;
    document.getElementById('choice').innerHTML = choice;
  }
  
  displayImage(witnessId);
}

var imageCount;

function displayImage(witnessId)
{
  for(var i in allImages.images)
  {
    if(allImages.images[i].id == witnessId)
    {
      new ImageMap(allImages.images[i].url);
    }
  }
}

function ImageMapType (options){
  options = options || {};
  this.tileSize = options.tileSize || new google.maps.Size(256, 256);
  this.maxZoom = options.maxZoom || 4;
  this.minZoom = options.minZoom || 1;
  this.name = options.name || 'Image';
  this.src= options.src || 'image/';
};

ImageMapType.prototype.getTile = function (coord, zoom, ownerDocument){
  var tilesCount = Math.pow(2, zoom);
  
  if( coord.x >= tilesCount || coord.x < 0 || coord.y >= tilesCount || coord.y < 0)
  {
    var div = ownerDocument.createElement('div');
    div.style.width = this.tileSize.width + "px";
    div.style.height = this.tileSize.height + "px";
    div.style.backgroundColor = "#FFF";
    return div;
  }
  
  var img = ownerDocument.createElement('img');
  img.width = this.tileSize.width;
  img.height = this.tileSize.height;
  img.src = this.src+(zoom)+'/'+coord.x+'_'+coord.y+".jpg";
  return img;
}


function ImageMap(url){
  options = {};
  options.mapTypeId = 'DRCImageMapType';
  options.center = options.center || new google.maps.LatLng(0, 0);
  options.zoom = options.zoom || 1;
  options.maxZoom = options.maxZoom || 4;
  options.minZoom = options.minZoom || 1;
  options.name = options.name || 'Image';
  options.src = options.src || 'http://textualcommunities.usask.ca' + url;
  options.streetViewControl = false;
  options.mapTypeControlOptions = options.mapTypeControlOptions || {
    mapTypeIds: [],
    style: null
  };
  var image = {
    src: 'http://textualcommunities.usask.ca' + url,
    width: 1707,
    height: 2514
  }
  this.rate = image.width > image.height ?  256/image.width : 256/image.height;
  this.x_fix = (256 - this.rate*image.width)/2;
  this.y_fix = (256 - this.rate*image.height)/2;
  var max = 256*Math.pow(2, options.zoom)-4;
  this.maxSize = {
    width: max-this.x_fix*Math.pow(2, options.zoom+1),
    height: max-this.y_fix*Math.pow(2, options.zoom+1)
  };
  
  var map = new google.maps.Map(
    document.getElementById("image_map"), options);

  map.mapTypes.set(options.mapTypeId, new ImageMapType(options));
 
  map.overlayView = new google.maps.OverlayView();
  map.overlayView.draw = function (){};
  map.overlayView.setMap(map);
//  google.maps.event.addListener(map, 'mousemove', function(e){
//    var div = document.getElementById('coord');
//    div.textContent = e.latLng.lat() + ', ' + e.latLng.lng();
//  });
  google.maps.event.addListener(map, 'projection_changed', function(e){
    var zoom = this.getZoom();
    var tile_num = Math.pow(2, zoom-1);
    var projection = this.getProjection();
    //console.log(tile_num);
    var latLng = projection.fromPointToLatLng(new google.maps.Point(64, 64));
    //console.log(projection);
    //console.log(latLng);
    this.setCenter(latLng);
  });
  this.map = map;
}

function loadRegTable()
{
  document.getElementById("reg_table_title").innerHTML = "Regularizations";
  var regRules = { rules: [] };
  
  regRules = allRules;

  //delete everything out of reg_table
   var table = document.getElementById('reg_table');
   var rowCount = table.rows.length;
   for(var i =rowCount-1; i>=0; i--)
   {
     table.deleteRow(i);
   }

  var table = document.getElementById('reg_table');

  var rowCount = table.rows.length;
  var row = table.insertRow(rowCount);
  
  var checkCellTitle = row.insertCell(0);
  checkCellTitle.innerHTML  = "Apply";
  var scopeCellTitle = row.insertCell(1);
  scopeCellTitle.innerHTML = "Scope";
  var regThisCellTitle = row.insertCell(2);
  regThisCellTitle.innerHTML = "Reg. This";
  var regToCellTitle = row.insertCell(3);
  regToCellTitle.innerHTML = "Reg. To";
  var deleteCellTitle = row.insertCell(4);
  deleteCellTitle.innerHTML = "Delete";
  
  rowCount++; 
  
  for(var i in regRules.rules)
  {
    var scope = regRules.rules[i].scope;
    var reg_this = regRules.rules[i].token;
    var reg_to = "";
    action = regRules.rules[i].action;
    reg_this = action.split(',')[0];
    reg_this = reg_this.substring(11,reg_this.length);
    reg_to = action.split(', ')[1];
    reg_to = reg_to.substring(0, reg_to.length-1);
    var modifications = regRules.rules[i].modifications;
    var isDisabled = false;
    if (modifications[modifications.length-1].modification_type == "delete")
    {
      isDisabled = true; 
    }
    
    insertRegTable(scope, reg_this, reg_to, isDisabled);
  	
  	rowCount++;
  }
  
  document.edit_reg.style.visibility = "visible";
}

function insertRegTable(scope, reg_this, reg_to, isDisabled)
{
    if(reg_this == null)
    {
      reg_this = "null";
    }
    
    if(reg_to == null)
    {
      reg_to = "null";
    }
    
    var found = true;
    if(isCustomRules)
    {
      found = false;
      //alert("isCustom: insertRegTable"); 
      
      for(var i in customRules.rules)
      {
        var customScope = customRules.rules[i].scope;
      	var action = customRules.rules[i].action;
        var reg_thisRule = action.split(',')[0];
        reg_thisRule = reg_thisRule.substring(11,reg_thisRule.length);
        var reg_toRule = action.split(', ')[1];
        reg_toRule = reg_toRule.substring(0, reg_toRule.length-1);
        var scopeRule = customRules.rules[i].scope;
	  	
        //TODO: add more when completed rules
        if(customScope == scope && reg_this == reg_thisRule && reg_to == reg_toRule)
        {
          found = true;
        }
      }
    }
    
    var table = document.getElementById('reg_table');

    var rowCount = table.rows.length;
  	var row = table.insertRow(rowCount);
    
    var checkCell = row.insertCell(0);
  	var element1 = document.createElement("input");
  	element1.type = "checkbox";
  	if(found)
  	{
  	  element1.checked = "checked";
  	}
        if(isDisabled)
        {
          element1.disabled = true;
        }
  	checkCell.appendChild(element1);
  	
  	var scopeCell = row.insertCell(1);
  	var element2 = document.createElement("select");
  	var option1 = document.createElement("option");
  	option1.text = "All witnesses, this entity";
        if(isDisabled)
        {
          element2.disabled = true;
        }
  	element2.options.add(option1);
  	var option2 = document.createElement("option");
  	option2.text = "All witnesses, this place";
  	element2.options.add(option2);
  	var option3 = document.createElement("option");
  	option3.text = "All witnesses, all places";
  	element2.options.add(option3);
  	if(scope == "all_places")
  	{
  	  element2.selectedIndex = 2; 
  	}
  	else if (scope == "this_place")
  	{
  	  element2.selectedIndex = 1;
  	}
  	scopeCell.appendChild(element2);
  	
  	var regThisCell = row.insertCell(2);
  	var element3 = document.createElement("input");
  	element3.type = "text";
  	element3.size = "25";
  	//regThisCell.innerHTML = reg_this;
  	element3.value = reg_this;
        if(isDisabled)
        {
          element3.disabled = true;
        }
  	regThisCell.appendChild(element3);
  	
  	var regToCell = row.insertCell(3);
  	var element4 = document.createElement("input");
  	element4.type = "text";
  	element4.size = "25";
  	element4.value = reg_to;
        if(isDisabled)
        {
          element4.disabled = true;
        }
  	regToCell.appendChild(element4);
  	
  	
  	var deleteCell = row.insertCell(4);
  	deleteCell.align = "center";
  	var element5 = document.createElement("input");
  	element5.type = "checkbox";
  	//element5.checked = "checked";
        if(isDisabled)
        {
          element5.disabled = true;
        }
  	deleteCell.appendChild(element5);
}

function getBaseTokens()
{
  var newTokens = { alignment: [] };
  $.ajax({
        url: "http://127.0.0.1:8000/regularization/getBaseTokens/",
        dataType: 'json',
        async: false,
        success: function(data){
          for(var i in data.alignment)
          {
            for(var j in data.alignment[i].tokens)
            {
                for(var k in allTokens.alignment[i].tokens)
                {
                  if(allTokens.alignment[i].tokens[k] != null && data.alignment[i].tokens[j] != null)
                  {
                    if(allTokens.alignment[i].tokens[k].t == data.alignment[i].tokens[j].t)
                    {
                      data.alignment[i].tokens[j].origToken = allTokens.alignment[i].tokens[k].origToken;
                    }
                  }
                }
            }
          }
          
          newTokens = data;
        }
    });
    
  return newTokens;
}

function submitCustomReg()
{
  // for alignments
  if(alignOn)
  {
    isCustomAlign = true;
    
    var table = document.getElementById("reg_table");
    var rowCount = table.rows.length;
    
    customAligns = { alignments: [] };
    var sendAligns = { alignments: [] };
    var aligns = allAlign;
    
    for(var i=1; i<rowCount; i++)
    {
      var row = table.rows[i];
      var check = row.cells[0].childNodes[0];
      var deleteCell = row.cells[6].childNodes[0];
      var index = i - 1;
      
      if(check.checked)
      {
        customAligns.alignments.push(aligns.alignments[index]);
      }
      
      if(deleteCell.checked)
      { 
        var newAlign = aligns.alignments[index];
        newAlign.modifications.push({
          "userId": userName,
          "modification_type": "delete",
          "dateTime" : getDateTime()
        });
        customAligns.alignments.push(newAlign);
        allAlign.alignments[index].modifications.push({
          "userId": userName,
          "modification_type": "delete",
          "dateTime" : getDateTime()
        });
        sendAligns.alignments.push(newAlign);
      }
    }
    
    sendAligns.urn = urn;
    sendAligns.userName = userName;
    sendAligns.ruleSetName = ruleSetName;
    
    //console.log(sendAligns);

    // send changed rules to server
    $.ajax({
        url: "http://127.0.0.1:8000/regularization/changeAligns/",
        dataType: 'json',
        type: 'POST',
        async: false,
        data: JSON.stringify(sendAligns),
        success: function(data){
    }});
  
    sendAligns = {alignments:[]};
    
    allTokens = getBaseTokens();
    origTokens = createNewAllTokens();
    
    regularize();
    //);
    loadAlignTable();
    
    ////console.log(allAlign);
    
    return;
  }
  
  // for regularization rules
  isCustomRules = true;  // ??!! <----
  var table = document.getElementById('reg_table');
  var rowCount = table.rows.length;
  
  customRules = { rules: [] };
  //first one is one to delete; second is new reg
  var sendRules = { rules: [] };
  
  var regRules = allRules;
  
  for(var i=1; i<rowCount; i++)
  {
    var row = table.rows[i];
    var check = row.cells[0].childNodes[0];
    var deleteRule = row.cells[4].childNodes[0];
    var index = i - 1;
    var scope = row.cells[1].childNodes[0].value;
    var reg_this = row.cells[2].childNodes[0].value;
    var reg_to = row.cells[3].childNodes[0].value;

    if(scope == "All witnesses, this entity")
    {
      scope = "this_entity";
    }
    else if(scope == "All witnesses, this place")
    {
      scope = "this_place";
    }
    else
    {
      scope = "all_places";
    }

    var action = regRules.rules[index].action;
    var reg_thisRule = action.split(',')[0];
    reg_thisRule = reg_thisRule.substring(11,reg_thisRule.length);
    var reg_toRule = action.split(', ')[1];
    reg_toRule = reg_toRule.substring(0, reg_toRule.length-1);
    var scopeRule = regRules.rules[index].scope;
    
    if(deleteRule != null && deleteRule.checked)
    {
      // delete from database
      var newRule = allRules.rules[index];
      newRule.modifications.push({
        "userId " : userName,
        "modification_type" : "delete",
        "dateTime" : getDateTime()
      });
      customRules.rules.push(newRule);
      sendRules.rules.push(newRule);
    }
    else if(check != null && check.checked)
    {
      if(reg_this == reg_thisRule && reg_to == reg_toRule && scope == scopeRule)
      {
        //add to customReg
        customRules.rules.push(regRules.rules[index]);
      }
      else
      {
        var rule = allRules.rules[index];
        var thisChange = false;
        if(reg_this != reg_thisRule)
        {
          rule.modifications.push({
            "userId": userName,
            "modification_type": "modify(reg_this," + reg_thisRule + "," + reg_this + ")",
            "dateTime": getDateTime()
          });
          sendRules.rules.push(rule);
          rule.action = "regularize(" + reg_this + "," + reg_toRule + ")";
          thisChange = true;
        }
        
        if(reg_to != reg_toRule)
        {
          rule.modifications.push({
            "userId": userName,
            "modification_type": "modify(reg_to," + reg_toRule + "," + reg_to + ")",
            "dateTime": getDateTime()
          });
          sendRules.rules.push(rule);
          if(thisChange)
          {
            rule.action = "regularize(" + reg_thisRule + "," + reg_to + ")";
          }
          else
          {
            rule.action = "regularize(" + reg_this + "," + reg_to + ")"; 
          }
        }
        
        if(scope != scopeRule)
        {
          rule.modifications.push({
            "userId": userName,
            "modification_type": "modify(scope," + scopeRule + "," + scope + ")",
            "dateTime": getDateTime()
          });
          sendRules.rules.push(rule);
          rule.scope = scope;
        }
        
        customRules.rules.push(rule)

      }
    }
    
    sendRules.urn = urn;
    sendRules.userName = userName;
    sendRules.ruleSetName = ruleSetName;

    // send changed rules to server
    $.ajax({
        url: "http://127.0.0.1:8000/regularization/changeRules/",
        dataType: 'json',
        type: 'POST',
        async: false,
        data: JSON.stringify(sendRules),
        success: function(data){
    }});
  
    sendRules = {rules:[]};
  }
  
  // get new/all rules and reload reg_table
  allTokens = getBaseTokens();
  
  regularize();
  //);
  loadRegTable();
}

function getDateTime()
{
  var currentDate = new Date();
  var day = currentDate.getDate();
  var month = currentDate.getMonth() + 1;
  var year = currentDate.getFullYear();
  var hours = currentDate.getHours();
  var minutes = currentDate.getMinutes();
  var seconds = currentDate.getSeconds();
  var dateTime = hours + ":" + minutes + ":" + seconds + " " + month + "/" + day + "/" + year
  
  return dateTime;
}

function createRule(scope, reg_this, reg_to, token, id, index)
{
 
  contextStruct = {witnesses:[]};
  var goForward;
  var context = reg_this;
  
  if(currentPosition == totalPos-1)
  {
    goForward = false;
  }
  else
  {
    goForward = true;
  }
  
  if(scope == "this_place")
  {
      contextStruct.witnesses.push({
        "id": id,
        "token": token,
        "context": reg_this,
        "tokenPos": currentPosition,
        "startPos": currentPosition,
        "endPos": currentPosition,
        "goForward": goForward,
        "switchDirections": true
        
      });
      context = getContext(id, index);
      
      var contextRegTo = context.replace(reg_this, reg_to);
      reg_to = contextRegTo;
  }
  
  dateTime = getDateTime();
  
  var action = "regularize(" + context + ", " + reg_to + ")";
  newRule = {
             "_id" : "",
             "appliesTo" : urn,
             "action" : action,
             "modifications" : [{
               "userId": userName,
               "modification_type": "create",
               "dateTime": dateTime
             }],
             "scope" : scope,
             "token" : token
           };
           
           
  //console.log(newRule);
  return newRule;

}

function automateReg(checkBox)
{
  
  if(checkBox.checked)
  {
    autoReg = true; 
    
    var maxPosition = 0;
    var maxLength = 0;
    
    for (var i in distinct.witnesses)
    {
      var numberIds = 0;
      for(var j in distinct.witnesses[i].originals)
      {
        for(var k in distinct.witnesses[i].originals[j].id)
        {
          numberIds++;
        }
      }
       
      // nothing should ever be regularized to null
      if(numberIds > maxLength && distinct.witnesses[i].token != "null")
      {
        maxPosition = i;
        maxLength = numberIds;
      }
    }
   
    
    document.regularization.reg_to.value = distinct.witnesses[maxPosition].token;
    
    // null should never be regularized to anything ?!?
    if(distinct.witnesses[maxPosition] == "null")
    {
      maxPosition++;
    }
    
    if(maxPosition != distinct.witnesses.length-1)
    {
      maxPosition++;
      document.regularization.reg_this.value = distinct.witnesses[maxPosition].token;
    }
    else if(maxPosition != 0 && maxPosition == distinct.witnesses.length)
    {
      document.regularization.reg_this.value = distinct.witnesses[0].token;
    }
    
    reg_thisBox = document.regularization.reg_this.value;
    reg_toBox = document.regularization.reg_to.value;
    
  }
  else
  {
    autoReg = false;
    
    document.regularization.reg_this.value = "";
    document.regularization.reg_to.value = "";
  }
}

function backEntity()
{
  var temp = urn.split("Line=");
  var line = temp[1];
  temp = temp[0];
  if(line != "IR")
  {
    line = parseInt(line) - 1;
  }
  else if(line == 1)
  {
    line = "IR";
  }
  
  temp = temp+"Line="+line.toString();;
  var jdata = { urn: temp};
  jdata = JSON.stringify(jdata);
  getEntity(jdata);
  urn = temp;
  
  var temp = urn.split("entity=")[1];
  var entity = temp.split(":", 1)[0];
  var line = temp.split("Line=")[1];
  document.getElementById("title_label").innerHTML = "entity " + entity + ", line " + line;
  
}

function forwardEntity()
{
  var temp = urn.split("Line=");
  var line = temp[1];
  temp = temp[0];
  if(line == "IR")
  {
    line = 1;
  }
  else
  {
    line++;
  }
  
  temp = temp+"Line="+line.toString();
  var jdata = { urn: temp};
  jdata = JSON.stringify(jdata);
  getEntity(jdata);
  urn = temp;
  
  var temp = urn.split("entity=")[1];
  var entity = temp.split(":", 1)[0];
  var line = temp.split("Line=")[1];
  document.getElementById("title_label").innerHTML = "entity " + entity + ", line " + line;
}

function getEntity(jdata)
{
  
  $.ajax({
    url: "http://127.0.0.1:8000/regularization/postEntity/",
    dataType: 'json',
    type: 'post',
    async: false,
    data: jdata,
    success: function(data){
    }});
  
  
  $.ajax({
    url: "http://127.0.0.1:8000/regularization/sendEntity/",
    dataType: 'json',
    async: false,
    success: function(data){
      //console.log(data)
      allTokens = data.allTokens;
      allWitnesses = data.allWitnesses;
      origTokens = createNewAllTokens();
      totalPos = allTokens.alignment[0].tokens.length;
      allImages = data.allImages;
      currentPosition = 0;
      //console.log(allTokens);
      regularize();
      //);
  }});
}


function showOriginals(checkBox)
{ 
  if(checkBox.checked)
  {
    isOriginals = true;
  }
  else
  {
    isOriginals = false; 
  }
  regularize();
  //);
}

function showRegularization(checkBox)
{
  if(checkBox.checked)
  {
    document.getElementById("align_wrapper").innerHTML = "";
    document.regularization.change.checked = false;
    var regHTML = "<br /><br /><label id='reg_this'>Regularize This:</label>";
    regHTML += "<input type='text' name='reg_this' size='82'/> <br /><label id='reg_to'>To This:</label>";
    regHTML += "<input type='text' name='reg_to' size='92'/>";
    regHTML += "<p>Regularize Choices:";
    regHTML += "<select name='reg_choices'>";
    regHTML += "<option value='this_entity'>All witnesses, this entity</option>";
    regHTML += "<option value='this_place'>All witnesses, this place</option>";
    regHTML += "<option value='all_places'>All witnesses, all places</option>";
    regHTML += "<option value='other'>Other ...</option>";
    regHTML += "</select></p>";
    regHTML += "<input name='ok' type='button' value='Add Rule'";
    regHTML += "onclick='addRule()'>";
    regHTML += "<input name='recollateTokens' type='button' value='Recollate' onclick='recollate()'/>";
    regHTML += "<input name='view' type='button' value='View Entire Reg.' onclick='seeWitnesses()'>";
    regHTML += "<br /> Shortcuts:: <br/>'Alt+Right Arrow': Add next word to Regularize This";
    regHTML += "<br /> 'Shift+Right Arrow': Add next word to Regularize To";
    regHTML += "<br /> 'Tab': Find next variant to regularize";
    regHTML += "<br /> 'Enter': Add rule";
    regHTML += "<br /> <input type='checkbox' name='automate' value='automate' id='automate'";
    regHTML += "onchange='automateReg(this)'/> <label id='automateLabel'>Automate regularization selection</label>";
    regHTML += "<br /> <input type='checkbox' name='originals' value='originals' onchange='showOriginals(this)'/>";
    regHTML += "<label id='showOriginals'>Show originals</label>";

    document.getElementById('reg_wrapper').innerHTML = regHTML;
    document.regularization.originals.style.visibility = "hidden";
    if(regOn)
    {
      document.edit_reg.style.visibility = "visible";
      document.getElementById("showOriginals").innerHTML = "Show originals";
      document.regularization.originals.style.visibility = "visible";
    }
    else
    {
      document.getElementById('showOriginals').innerHTML = "";
    }
    isRealign = false;
    loadRegTable();
  }
}

function showRealign(checkBox)
{
  
  if(checkBox.checked)
  {
    isRealign = true;
    //document.realign_token.style.visibility = "visible";
    document.regularization.reg_checkbox.checked = false;
    document.getElementById("reg_wrapper").innerHTML = "";
    
    var alignHTML = "Change token alignment: <input type='text' name='token' size='20'/>";
    alignHTML += "<br/> <input type='checkbox' id='move_realign' value='move_realign' onchange='changeKindCheckbox(this)'/> Move token";
    alignHTML += "<br/> <input type='checkbox' id='combine_realign' value='combine_realign' onchange='changeKindCheckbox(this)'/> Create phrase";
    //alignHTML += "<br/> <input type='checkbox' id='insert_realign' value='insert_realign' onchange='changeKindCheckbox(this)'/> Insert into tokens";
    alignHTML += "<br/><div id='alignOption_wrapper'></div>"
    alignHTML += "<br />";
    alignHTML += "<input name='submitRealign' type='button' value='Change' onclick='addAlign()'>";
    alignHTML += "<br />";
    alignHTML += "Old alignment: <label id='realign_this'></label>";
    alignHTML += "<br />";
    alignHTML += "New alignment: <label id='realign_to'></label>";
    
    document.getElementById("align_wrapper").innerHTML = alignHTML;
    document.edit_reg.style.visibility = "hidden";
    document.getElementById("move_realign").checked = true;
    changeKindCheckbox(document.getElementById("move_realign"));
    alignOn = false;
    align_onoff();
    
    //document.getElementById("move_realign").checked = true;
  }
  else
  {
    isRealign = false;
  }
  
  applyAlign();
}

function changeKindCheckbox(checkBox)
{
  if(checkBox.value == "move_realign")
  {
    document.getElementById("combine_realign").checked = false;
    
    document.getElementById("alignOption_wrapper").innerHTML = "";
    var alignHTML = "<br/>Direction:<br/>";
    alignHTML += "<input type='checkbox' name='forward_realign' value='forward_realign' id='forward_realign'";
    alignHTML += "onchange='alignmentDirection(this)'/> Forward";
    alignHTML += "<select name='forward_select' id='forward_select' onchange='getRealign()'></select>";
    alignHTML += "<br/>";
    alignHTML += "<input type='checkbox' name='backward_realign' value='bacward_realign' id='backward_realign'";
    alignHTML += "onchange='alignmentDirection(this)'/> Backward";
    alignHTML += "<select name='backward_select' id='backward_select' onchange='getRealign()'></select>";
    document.getElementById("alignOption_wrapper").innerHTML = alignHTML;
    document.getElementById("forward_realign").style.visibility = "visible";
    document.getElementById("backward_realign").style.visibility = "visible";
    document.getElementById("forward_select").style.visibility = "hidden";
    document.getElementById("backward_select").style.visibility = "hidden";
  }
  else
  {
    document.getElementById("move_realign").checked = false;
    document.getElementById("alignOption_wrapper").innerHTML = "";
    document.getElementById("alignOption_wrapper").innerHTML = "Shortcuts::<br/>'Alt+Right Arrow': Add next token to Change Alignment";
  }
}

function alignmentDirection(checkBox)
{
  if(checkBox.value == "forward_realign")
  {
    document.getElementById("backward_realign").checked = false;
    document.getElementById("forward_select").style.visibility = "visible";
    document.getElementById("backward_select").style.visibility = "hidden";
    
    document.getElementById("forward_select").options.length = 0;
    var option = document.createElement("option");
    option.text = "--";
    document.getElementById("forward_select").add(option);
    var numPos = totalPos - currentPosition;
    for(var i = 0; i < numPos; i++)
    {
      var option = document.createElement("option");
      option.text = i+1;
      document.getElementById("forward_select").add(option);
    }
  }
  else
  {
    document.getElementById("forward_realign").checked = false;
    document.getElementById("forward_select").style.visibility = "hidden";
    document.getElementById("backward_select").style.visibility = "visible";
    
    document.getElementById("backward_select").options.length = 0;
    var option = document.createElement("option");
    option.text = "--";
    document.getElementById("backward_select").add(option);
    for(var i = 0; i <= currentPosition; i++)
    {
      var option = document.createElement("option");
      option.text = i+1;
      document.getElementById("backward_select").add(option);
    }
  }
}

function realign(token, isMove, isForward, numPos, position)
{
  var isCreate = true;
  
  if(isMove)
  {
    isCreate = false;
  }
  
  if(token == "")
  {
    alert("Please select a token");
    return;
  }
  
  if(!regOn)
  {
    alert("Regularization must be on to change alignment");
    return;
  }
  
  if(!alignOn)
  {
    alert("Alignment must be on to change alignment");
    return;
  }
  
  if (token != "")
  {
    var ids = [];
    //console.log(distinct);

    for (var i in distinct.witnesses)
    {
      if(token == distinct.witnesses[i].token)
      {
        for (var j in distinct.witnesses[i].originals)
        {
          for (var k in distinct.witnesses[i].originals[j].id)
          {
            ids.push(distinct.witnesses[i].originals[j].id[k]);
          }
        }
      }
    }

//    console.log(ids);

    // MOVE TOKENS
    if(isMove)
    {
      if(isForward)
      {
        for(var i in allTokens.alignment)
        {
          var foundId = false;
          for (var j in ids)
          {
            if(allTokens.alignment[i].witness == ids[j])
            {
              foundId = true;
            }
          }

          if(foundId)
          {
            for(var k = 0; k < numPos; k++)
            {
              allTokens.alignment[i].tokens.splice(0, 0, "null");
              allTokens.alignment[i].tokens[0] = null;
            }
          }
          else
          { 
            var newPosition = totalPos + 1;
            for(var k = 0; k < numPos; k++)
            {
              allTokens.alignment[i].tokens.splice(newPosition, 0, null);
              newPosition++;
            }
          }
        }
        
      }
      else
      {
        for(var i in allTokens.alignment)
        {
          var foundId = false;
          for (var j in ids)
          {
            if(allTokens.alignment[i].witness == ids[j])
            {
              foundId = true;
            }
          }

          if(foundId)
          {
            newPosition = totalPos + 1;
            for(var k = 0; k < numPos; k++)
            {
              allTokens.alignment[i].tokens.splice(newPosition, 0, "null");
              newPosition++;
            }

            for(var k in allTokens.alignment[i].tokens)
            {
              if(allTokens.alignment[i].tokens[k] == "null")
              {
                allTokens.alignment[i].tokens[k] = null;
              }
            }
          }
          else
          {
            for(var k = 0; k < numPos; k++)
            {
              allTokens.alignment[i].tokens.splice(0, 0, "null");
              allTokens.alignment[i].tokens[0] = null;
            }
          }
        }
      }
    }
    
    // CREATE PHRASE
    if(isCreate)
    {
      if(token[token.length-1] == " ")
      {
        token.splice(token.length-1, 1);
      }

      token = token.split(" ");
      var length = token.length;
      
      for(var i in allTokens.alignment)
      {
        var match = true;
        var index = position;
        for (var j in token)
        {
          if(getToken(i, index) != token[j])
          {
            match = false;
          }
          index++;
        }
        
        if(match)
        {
          allTokens.alignment[i].tokens[position].t = token.join(" ");
          var indexInput = totalPos;
          var indexDelete = position;
          indexDelete++;
          
          for(var j = 0; j < length-1; j++)
          {
            allTokens.alignment[i].tokens[indexInput] = null;
            indexInput++;
          }
          
          for(var j=0; j < length-1; j++)
          {
            allTokens.alignment[i].tokens.splice(indexDelete, 1);
          }
        }
      }
    }
  }
  
  // Make sure there are no extra null positions in alignment
//  var endDelete = false;
//  for(var j = 0; j < totalPos; j++)
//  {
//    if(!endDelete)
//    {
//      var found = false;
//      for(var i in allTokens.alignment)
//      {
//        if(allTokens.alignment[i].tokens[0] != null)
//        {
//          found = true;
//          endDelete = true;
//        }
//      }
//      
//      if(!found)
//      {
//        for (var i in allTokens.alignment)
//        {
//          allTokens.alignment[i].tokens.splice(0,1);
//        }
//      }
//    }
//  }
//  
//  
//  var endDelete = false;
//  for(var j = 0; j < totalPos; j++)
//  {
//    if(!endDelete)
//    {
//      found = false;
//      for(var i in allTokens.alignment)
//      {
//        if(allTokens.alignment[i].tokens[allTokens.alignment[0].tokens.length-1] != null)
//        {
//          found = true;
//        }
//      }
//
//      if(!found)
//      {
//        for (var i in allTokens.alignment)
//        {
//          allTokens.alignment[i].tokens.splice(allTokens.alignment[0].tokens.length-1,1);
//        }
//      }
//    }
//  }
  
  //console.log(allTokens);
  totalPos = allTokens.alignment[0].tokens.length;
  regularize();
}

function getRealign()
{
  var oldAlign = "";
  var newAlign = "";
  var oldTotalPos = totalPos;
  
  var numPos = null;
  var isForward = null;
  var token = document.realign_token.token.value;
  var isMove = document.getElementById("move_realign").checked;
  
  if(isMove)
  {
    isForward = document.getElementById("forward_realign").checked;
    
    if(isForward)
    {
      numPos = document.getElementById("forward_select").value;
    }
    else
    {
      numPos = document.getElementById("backward_select").value;
    }
  }
  
  if(token == "")
  {
    alert("Please select a token");
    return;
  }
  
  if(!regOn)
  {
    alert("Regularization must be on to change alignment");
    return;
  }
  
  if(!alignOn)
  {
    alert("Alignment must be on to change alignment");
    return;
  }
  
  var newTokens = createNewAllTokens();
  var oldTokens = allTokens;
  allTokens = newTokens;
  
  if(document.getElementById("forward_realign").checked)
  {
    //OLDALIGN
    var numTokens = totalPos + parseInt(numPos);
    for(var i=0; i<numTokens; i++)
    {
      var position = i;
      if(position <= totalPos)
      { 
        oldAlign += findDistinct(position) + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
      else
      {
        oldAlign += getNullContent() + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
    }

    //NEWALIGN
    regularize();
    realign(token, isMove, isForward, numPos, currentPosition);
    var numTokens = totalPos + parseInt(numPos);
    for(var i = 0; i<numTokens; i++)
    {
      var position = i;
      if(position <= totalPos)
      { 
        newAlign += findDistinct(position) + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
      else
      {
        newAlign += getNullContent() + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
    }
  }
  else
  {
    
    //OLDALIGN
    var numTokens = totalPos + parseInt(numPos) - 1;
    var endPosition = 0 - parseInt(numPos);
    var position = 0;
    for(var i=numTokens; i>endPosition; i--)
    {
      if(i >= -1)
      { 
        oldAlign += findDistinct(position) + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
        position++;
      }
      else
      {
        oldAlign += getNullContent() + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
    }

    //NEWALIGN
    regularize();
    realign(token, isMove, isForward, numPos, currentPosition);
    var numTokens = totalPos + parseInt(numPos) - 1;
    var endPosition = 0 - parseInt(numPos);
    var position = 0;
    for(var i = numTokens; i>endPosition; i--)
    {
      if(i >= -1)
      { 
        newAlign += findDistinct(position) + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
        position++;
      }
      else
      {
        newAlign += getNullContent() + "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      }
    }
  }
  
  document.getElementById("realign_this").innerHTML = oldAlign;
  document.getElementById("realign_to").innerHTML = newAlign;
  
  // make distinct object correct
  allTokens = oldTokens;
  regularize();
  totalPos = oldTotalPos;
  //console.log(totalPos);
}

function getNullContent()
{
  var content = "null ";
  
  for(var i in allTokens.alignment)
  {
    content += allTokens.alignment[i].witness + " ";
  }
  content += "///";
  return content;
}

function createNewAllTokens()
{
  var newTokens;
  
  if(!isRecollate)
  {
    newTokens = {alignment: []};
  }
  else
  {
    newTokens = {witnesses:[]};
  }
  
  for(var i in allTokens.alignment)
  {
    
    if(!isRecollate)
    {
      newTokens.alignment.push({
        "witness": allTokens.alignment[i].witness,
        "tokens": []
      });

      for(var j in allTokens.alignment[i].tokens)
      {
        if(allTokens.alignment[i].tokens[j] == null)
        {
          newTokens.alignment[i].tokens.push(null);
        }
        else
        {
          newTokens.alignment[i].tokens.push({
            "t": allTokens.alignment[i].tokens[j].t
          });
        }
      }
    }
    else
    {
      newTokens.witnesses.push({
        "id": allTokens.alignment[i].witness,
        "tokens": []
      });
      
      for(var j in allTokens.alignment[i].tokens)
      {
        if(allTokens.alignment[i].tokens[j] == null)
        {
          newTokens.witnesses[i].tokens.push(null);
        }
        else
        {
          var token = "";
          token = getToken(i, j);
          newTokens.witnesses[i].tokens.push({
            "t": token
          });
        }
      }
    }
  }
  
  return newTokens;
}

function loadAlignTable()
{
  document.getElementById("reg_table_title").innerHTML = "Alignments";

  //delete everything out of reg_table
   var table = document.getElementById('reg_table');
   var rowCount = table.rows.length;
   for(var i =rowCount-1; i>=0; i--)
   {
     table.deleteRow(i);
   }

  var table = document.getElementById('reg_table');

  var rowCount = table.rows.length;
  var row = table.insertRow(rowCount);
  
  var checkCellTitle = row.insertCell(0);
  checkCellTitle.innerHTML = "Apply";
  var tokenCellTitle = row.insertCell(1);
  tokenCellTitle.innerHTML = "Token or Phrase";
  var positionCellTitle = row.insertCell(2);
  positionCellTitle.innerHTML = "Witness ID";
  var typeCellTitle = row.insertCell(3);
  typeCellTitle.innerHTML = "Type";
  var directionCellTitle = row.insertCell(4);
  directionCellTitle.innerHTML = "Direction";
  var numCellTitle = row.insertCell(5);
  numCellTitle.innerHTML = "Number of Positions";
  var deleteCellTitle = row.insertCell(6);
  deleteCellTitle.innerHTML = "Delete";
  
  rowCount++; 
  
  for(var i in allAlign.alignments)
  {
    var token = allAlign.alignments[i].token;
    var witnessId = allAlign.alignments[i].witnessId;
    var type = allAlign.alignments[i].isMove;
    var direction = allAlign.alignments[i].isForward;
    var numPos = allAlign.alignments[i].numPos;
    var modifications = allAlign.alignments[i].modifications;
    var isDisabled = false;
    if (modifications[modifications.length-1].modification_type == "delete")
    {
      isDisabled = true; 
    }
    
    insertAlignTable(token, witnessId, type, direction, numPos, isDisabled);
    rowCount++;
  }
  
  document.edit_reg.style.visibility = "visible";
}

function insertAlignTable(token, witnessId, isMove, isForward, numPos, isDisabled)
{
  var table = document.getElementById('reg_table');

  var rowCount = table.rows.length;
  var row = table.insertRow(rowCount);

  var checkCell = row.insertCell(0);
  var element1 = document.createElement("input");
  element1.type = "checkbox";
  element1.checked = true;
  var found = false;
  for(var i in customAligns.alignments)
  {
    var customToken = customAligns.alignments[i].token;
    var customID = customAligns.alignments[i].witnessID;
    var customMove = customAligns.alignments[i].isMove;
    var customForward = customAligns.alignments[i].isForward;
    var customNumPos = customAligns.alignments[i].numPos;
    if(customToken == token && customID == witnessId && isMove == customMove && isForward == customForward && numPos == customNumPos)
    {
      found = true;
    }
  }
  if(found)
  {
    element1.checked = "checked";
  }
  if(isDisabled)
  {
    element1.disabled = true;
  }
  checkCell.appendChild(element1);
  
  var tokenCell = row.insertCell(1);
  var element2 = document.createElement("label");
  element2.innerHTML = token;
  tokenCell.appendChild(element2);
  
  var positionCell = row.insertCell(2);
  var element3 = document.createElement("label");
  element3.innerHTML = witnessId;
  positionCell.appendChild(element3);
  
  var typeCell = row.insertCell(3);
  var element4 = document.createElement("label");
  if(isMove)
  {
    element4.innerHTML = "Move tokens";
  }
  else
  {
    element4.innerHTML = "Create phrase";
  }
  typeCell.appendChild(element4);
  
  var directionCell = row.insertCell(4);
  var element5 = document.createElement("label");
  if(isMove)
  {
    if(isForward)
    {
      element5.innerHTML = "Forward";
    }
    else
    {
      element5.innerHTML = "Backward";
    }
  }
  else
  {
    element5.innerHTML = "--";
  }
  directionCell.appendChild(element5);
  
  var numberCell = row.insertCell(5);
  var element6 = document.createElement("label");
  if(isMove)
  {
    element6.innerHTML = numPos;
  }
  else
  {
    element6.innerHTML = "--";
  }
  numberCell.appendChild(element6);

  var deleteCell = row.insertCell(6);
  deleteCell.align = "center";
  var element7 = document.createElement("input");
  element7.type = "checkbox";
  if(isDisabled)
  {
    element7.disabled = true;
  }
  deleteCell.appendChild(element7);
}

function align_onoff()
{
  if(alignOn)
  {
    alignOn = false;
    document.getElementById("align_button").value = "Align. Off";
    allTokens = getBaseTokens();
    origTokens = createNewAllTokens();
  }
  else
  {
    alignOn = true;
    document.getElementById("align_button").value = "Align. On";
    //allTokens = origTokens;
    //);
    loadAlignTable();
  }
  regularize();
  //);
}

function createAlignment(token, isMove, isForward, numPos)
{
  var allNewAlign = { alignments: [] };
  contextStruct = {witnesses: []};
  origTokens = getBaseTokens();
  
  if(isForward == null)
  {
    isForward = false;
  }
  
  if(numPos == null)
  {
    numPos = 0;
  }
  
  if(token[token.length-1] == " ")
  {
    token.splice(token.length-1, 1);
  }

  token = token.split(" ");
  var witnessId = "";
  var context = "";

  for(var i in allTokens.alignment)
  {
    var match = true;
    var index = currentPosition;
    context = "";
    for (var j in token)
    {
      if(getToken(i, index) != token[j])
      {
        match = false;
      }
      index++;
    }

    if(match)
    {
      witnessId = allTokens.alignment[i].witness;
      
      if(currentPosition == totalPos-1)
      {
        goForward = false;
      }
      else
      {
        goForward = true;
      }
      
      contextStruct.witnesses.push({
        "id": witnessId,
        "token": token[0],
        "context": token.join(" "),
        "tokenPos": currentPosition,
        "startPos": currentPosition,
        "endPos": currentPosition,
        "goForward": goForward,
        "switchDirections": true
        
      });
      
      console.log(contextStruct);
      
      var index = 0;
      for(var j in distinct.witnesses)
      {
        if(token[0] == distinct.witnesses[j].token)
        {
          index = j;
        }
      }
      
      context = getContext(witnessId, index);
      
      
      var newAlign = {
        "token": token.join(" "),
        "appliesTo": urn,
        "witnessId": witnessId,
        "context": context,
        "isMove": isMove,
        "isForward": isForward,
        "numPos": numPos,
        "position": currentPosition,
        "modifications": []
      };

      newAlign.modifications.push({
        "modification_type": "create",
        "userName": userName,
        "dateTime": getDateTime()
      });
      
      console.log(newAlign);
      
      allNewAlign.alignments.push(newAlign);
    }
  }
  
  return allNewAlign;
}

function addAlign()
{
  var numPos = null;
  var isForward = null;
  var token = document.realign_token.token.value;
  var isMove = document.getElementById("move_realign").checked;
  document.getElementById("realign_this").innerHTML = "";
  document.getElementById("realign_to").innerHTML = "";
  
  if(isMove)
  {
    isForward = document.getElementById("forward_realign").checked;
    
    if(isForward)
    {
      numPos = document.getElementById("forward_select").value;
    }
    else
    {
      numPos = document.getElementById("backward_select").value;
    }
    
    if(numPos == "--")
    {
      alert("Select number of positions to move token");
      return;
    }
  }
  
  newAlign = createAlignment(token, isMove, isForward, numPos);
  
  for(var i in newAlign.alignments)
  {
    allAlign.alignments.push(newAlign.alignments[i]);
    // add to table
    insertAlignTable(newAlign.alignments[i].token, newAlign.alignments[i].witnessId, newAlign.alignments[i].isMove, newAlign.alignments[i].isForward, newAlign.alignments[i].numPos, false);
  }
  
  //send to server
  sendAlign(newAlign);
  
  // do alignment
  realign(token, isMove, isForward, numPos, currentPosition);
  
}

function sendAlign(newAlign)
{
  var sendAligns = {alignments: []};
  
  for(var i in newAlign.alignments)
  {
    sendAligns.alignments.push(newAlign.alignments[i]);
  }
  //console.log(sendAligns);
  sendAligns.urn = urn;
  sendAligns.userName = userName;
  sendAligns.ruleSetName = ruleSetName;
  
    $.post("http://127.0.0.1:8000/regularization/postNewAlign/",
       JSON.stringify(sendAligns), function(data){
       //alert("success");
     })
   .error(function () {alert("error: saveAlign");})

}

/**
 * applies ALL alignments
 */
function applyAlign()
{
  var aligns = {alignments: []};
  if(isCustomAlign)
  {
    aligns = customAligns;
  }
  else
  {
    aligns = allAlign;
  }
  
  if(!alignOn)
  {
    return;
  }
  
  for (var i in aligns.alignments)
  {
    var token = aligns.alignments[i].token;
    var isMove = aligns.alignments[i].isMove;
    var isForward = aligns.alignments[i].isForward;
    var numPos = aligns.alignments[i].numPos;
    var context = aligns.alignments[i].context;
    var witnessId = aligns.alignments[i].witnessId;
    var position = aligns.alignments[i].position;
    var foundMatch = true;
    var tokenArray = token.split(" ");
    var alignApplied = false;
    if(aligns.alignments[i].modifications[aligns.alignments[i].modifications.length-1].modification_type != "delete")
    {
      for(var j in allTokens.alignment)
      {
        if(allTokens.alignment[j].witness == witnessId && !alignApplied)
        {
          //alert("match witnessId: " + witnessId);
          for(var k in allTokens.alignment[j].tokens)
          {
            findDistinct(k);
            //alert("At: " + getToken(j, k) + " alignTok: " + tokenArray[0]);
            if(getToken(j, k) == tokenArray[0])
            {
              //alert("match Token: " + tokenArray[0]);
              //alert("Context: " + context);
              var contextArray = context.split(" ");
              var index = "";

              for(var l in allTokens.alignment)
              {
                if(witnessId == allTokens.alignment[l].witness)
                {
                  witnessId = l;
                }
              }

              for(var m in contextArray)
              {
                if(tokenArray[0] == contextArray[m])
                {
                  index = m;
                }
              }

              var numBack = k - index;
              for(var m = 0; m<index; m++)
              {
                //alert(numBack);
                if(allTokens.alignment[witnessId].tokens[numBack] != null)
                {
                  if(allTokens.alignment[witnessId].tokens[numBack].t != contextArray[m] && foundMatch)
                  {
                    //alert("backward no match");
                    foundMatch = false;
                  }
                }
                else
                {
                  m--;
                }
                numBack--;
              }

              var numForward = k;
              for(var m = index + tokenArray.length - 1; m < contextArray.length; m++)
              {
                if(allTokens.alignment[witnessId].tokens[numForward] != null)
                {
                  if(allTokens.alignment[witnessId].tokens[numForward].t != contextArray[m] && foundMatch)
                  {
                    //alert("forward no match");
                    foundMatch = false;
                  }
                }
                else
                {
                  m++;
                }
                numForward++;
              }

              if(foundMatch && !alignApplied)
              { 
                 alert("match: " + witnessId);
                 alignApplied = true;
                 realign(token, isMove, isForward, numPos, k);
              }
            }
          }
        }
      }
    }
  }
  
  console.log(allTokens);
}

</script>
</head>

<body onload="load()">
  <h1>Collation Interface: for <label for="title_label" id="title_label"></label></h1>
<label for="regularize_label" id="regularize_label">Single click on the word you want regularized, double click or type in the
word you want it regularized to.  <br/>Select combination of Witnesses and Place.  Click OK when finished.</label>
<br /><br /><label for="reg_on" id="reg_on">Regularization is off! (Showing
originals)
</label>

<table>
  <tr>
    <td>
      <table>
<tr>
<td style="width: 30px">
<form action="." method="POST" name="regularization">
       <br /><textarea rows="10" cols="75" name="reg" onclick="determineClick()"></textarea>
       
       <br /> <input type="checkbox" name="reg_checkbox" value="reg_checkbox" onchange="showRegularization(this)"/>
        Add regularization rules
       <br /> <input type="checkbox" name="change" value="change" onchange="showRealign(this)"/>
        Change alignment of token
       <br />
       
       <input name="reg_on" id="reg_button" type="button" value="Reg. On" onclick="regularize_onoff()">
       <input name="align_on" id="align_button" type="button" value="Align. Off" onclick="align_onoff()">
       <input name="back" type="button" value="Back Entity" onclick="backEntity()">
       <input name="forward" type="button" value="Forward Entity" onclick="forwardEntity()">
       <input name="previous" type="button" value="Previous Word" onclick="previousToken()">
       <input name="next" type="button" value="Next Word" onclick="nextToken()">
       <input name="done" type="button" value="Done"><br/>
    
       <div id="reg_wrapper"></div><br />
       
</form>

  <form name="realign_token" id="realign_token">
    <div id="align_wrapper"></div><br/>
    </form>
</td>
</tr>

<tr>
  <td>
<form name="edit_reg">
  <label id="reg_table_title">Regularizations</label>

<table id="reg_table" border="1">
	
</table>

<input name="submit" type="button" value="Submit" onclick="submitCustomReg()">

</form>
  </td>
</tr>
      </table>
    </td>
    <td>
      <table>
        <tr>
            <td valign="top">
  <label id="newRegInfo"></label><br/>
<form action="." method="POST" name="information">
<h2>Witness Information</h2>
Word <label for="word" id="word"></label> in line <label for="line" id="line"></label> in entity <label for="block" id="block"></label>
in witness <label for="witnessId" id="witnessId"></label>

<br /><br />

Context:<br/>
<label for="context" id="context"></label>

<br /><br />

</form>
<form action="." method="POST" name="reg_information">
Regularization from:<br/>
<label for="reg_this_info" id="reg_this_info"></label>

<br /><br />

Regularization to:<br/>
<label for="reg_to_info" id="reg_to_info"></label>

<br /><br />

This regularization set for <label for="choice" id="choice"></label>
</form>
        </tr>
        <tr>
  <td><div id="image_map" style="width:384px;height:384px;margin:0px auto;"></div></td>
</tr>
</table>
    </td>
  </tr>
</table>
</body> </html>
