<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>Collate Interface</title>
<script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
<script type="text/javascript">
  
  var userName = "{{ userName }}";
  var urn = "{{ urn }}";
  var ruleSetName = "{{ ruleSetName }}";
  var witnessDataTokens = (("{{ witnessesTokens}}")).replace(/&(l|g|quo)t;/g, function(a,b)
  {
    return {
      l : '<',
      g : '>',
      quo : '"'
    }[b];
  });
  var witnessDataLines = (("{{ witnessesLines}}")).replace(/&(l|g|quo)t;/g, function(a,b)
  {
    return {
      l : '<',
      g : '>',
      quo : '"'
    }[b];
  });
  var ruleSet = (("{{ ruleSet }}")).replace(/&(l|g|quo)t;/g, function(a,b)
  {
    return {
      l : '<',
      g : '>',
      quo : '"'
    }[b];
  });

var allWitnesses;
var newRules;
var contextStruct;
var allTokens;
var totalPos;
var currentPosition = "{{ position }}";
var regOn;
var iTimeoutId = null;
var allRules;
var reg_thisBox;
var reg_toBox;
var origTokens;
var isBuildWitnesses;
var isRecollate;
var customRules;
var isCustomRules;
var autoReg;
var distinct;
var changeLabelTimer = null;
var isOriginals;

function load()
{
  witnessDataTokens = witnessDataTokens.replace(/u'/g, '\'');
  witnessDataTokens = witnessDataTokens.replace(/'/g, '\"');
  witnessDataTokens = JSON.parse(witnessDataTokens);

  witnessDataLines = witnessDataLines.replace(/u'/g, '\'');
  witnessDataLines = witnessDataLines.replace(/'/g, '\"');
  witnessDataLines = JSON.parse(witnessDataLines);
  
  ruleSet = ruleSet.replace(/u'/g, '\'');
  ruleSet = ruleSet.replace(/'/g, '\"');
  ruleSet = JSON.parse(ruleSet);
  
  document.getElementById("title_label").innerHTML = urn;
  document.information.style.visibility = "hidden";
  document.reg_information.style.visibility ="hidden";
  document.edit_reg.style.visibility = "hidden";
  document.regularization.originals.style.visibility = "hidden";
  document.getElementById("showOriginals").style.visibility = "hidden";
  isOriginals = false;
  lineNumber = 0;
  newRules = { rules: [] };
  customRules = { rules: [] };
  allRules = { rules: ruleSet.ruleSet.rules};

  contextStruct = { witnesses: [] };

  regOn = false;
  
  isBuildWitnesses = false;
  isRecollate = false;
  isCustomRules = false;
  autoReg = false;
  distinct = { witnesses: [] };
  
   // add keyboard shortcut
  shortcut.add("Alt+Right", function () {
    addTokenThis();
  });

  shortcut.add("Shift+Right", function () {
    addTokenTo();
  });

  shortcut.add("Tab", function() {
    findNextVariant();
  });
  
  shortcut.add("Enter", function() {
      addRule();
    });
    
  allTokens = witnessDataTokens;
  origTokens = witnessDataTokens;
  allWitnesses = witnessDataLines;
  regularize(newRules);
}

function nextToken()
{
  var reg_toWhole = document.regularization.reg_to.value;
  document.regularization.reg_this.value = "";
  //document.regularization.reg_to.value = "";

  if(currentPosition == totalPos)
  {
    if(regOn)
    {
      if(isRecollate)
      {
        recollate();
        isRecollate = false;
      }
      
      if(isCustomRules)
      {
        var regRules = customRules;
      }
      else
      {
        var regRules = allRules;
      }
      
      for(var i in newRules.rules)
      {
        regRules.rules.push(newRules.rules[i]);
      }
      regularize(regRules);
    }
    else
    {
      allTokens = origTokens;
      regularize(newRules);
    }
  }
  else
  {
    if(regOn)
    {
      if(isRecollate)
      {
        recollate();
        isRecollate = false;
      }
      
      if(isCustomRules)
      {
        var regRules = customRules;
      }
      else
      {
        var regRules = allRules;
      }
      
      currentPosition++;
      for(var i in newRules.rules)
      {
        regRules.rules.push(newRules.rules[i]);
      }
      regularize(regRules);
    }
    else
    {
      currentPosition++;
      allTokens = origTokens;
      regularize(newRules);
    }
    
  }
  
  document.regularization.reg_to.value = reg_toWhole;
}

function previousToken()
{
  var reg_toWhole = document.regularization.reg_to.value;
  document.regularization.reg_this.value = "";
  //document.regularization.reg_to.value = "";

  if(currentPosition == 0)
  {
    if(regOn)
    {
      if(isRecollate)
      {
        recollate();
        isRecollate = false;
      }
      
      if(isCustomRules)
      {
        var regRules = customRules;
      }
      else
      {
        var regRules = allRules;
      }
      
      for(var i in newRules.rules)
      {
        regRules.rules.push(newRules.rules[i]);
      }
      regularize(regRules);
    }
    else
    {
      allTokens = origTokens;
      regularize(newRules);
    }
  }
  else
  {
    if(regOn)
    {
      if(isRecollate)
      {
        recollate();
        isRecollate = false;
      }
      
      if(isCustomRules)
      {
        var regRules = customRules;
      }
      else
      {
        var regRules = allRules;
      }
      currentPosition--;
      
      for(var i in newRules.rules)
      {
        regRules.rules.push(newRules.rules[i]);
      }
      regularize(regRules);
    }
    else
    {
      currentPosition--;
      allTokens = origTokens;
      regularize(newRules);
    }
    
  }
  
  document.regularization.reg_to.value = reg_toWhole;
}

function determineClick()
{
  if (iTimeoutId == null || !iTimeoutId)
  {
    iTimeoutId = setTimeout("selectToken()", 500);
  }
  else
  {
    window.clearTimeout(iTimeoutId);
    iTimeoutId = null;
    selectNew();
  }
}

function findWord(pos, content)
{
  //find whitespaces -- find word indexes
    var found = false;
    var endPos = pos;
    while(!found)
    {
      if(content[endPos] != " ")
      {
        endPos++;
      }
      else
      {
        found = true;
      }
    }

    found = false;
    var startPos = pos;
    while(!found)
    {
      if(content[startPos] != " ")
      {
        if(startPos != 0)
        {
          startPos--;
        }
        else
        {
          found = true;
        }
      }
      else
      {
        found = true;
      }
    }

  var length = endPos - startPos;
  var token = content.substr(startPos, length);
  token = token.split(" ");
  token = token.join("");
  var origToken = token;
  token = token.split("(")[0];

  var notToken = false;
  var isId = false;
  for(var i in allWitnesses.witnesses)
  {
    if(token == allWitnesses.witnesses[i].id)
    {
      informationWindow(allWitnesses.witnesses[i].id);
      isId = true;
      token = "isId";
    }
  }
  
  if(!isId)
  {
    token = origToken;
  }

  if(token == "///" || token == "" || token == "null")
  {
    notToken = true;
  }

  if(notToken)
  {
    return false;
  }
  else
  {
    return token;
  }
}

function selectToken()
{
    window.clearTimeout(iTimeoutId);
    iTimeoutId = null;
    
    var content = document.regularization.reg.value;
    var txt = document.regularization.reg;
    var pos = txt.selectionStart;

    var token = findWord(pos, content);

    if(!token)
    {
      alert("Invalid selection");
    }
    else if(token != "isId")
    {
      document.regularization.reg_this.value = token;
      reg_thisBox = token;
    }

}

function selectNew()
{
  window.clearTimeout(iTimeoutId);
  iTimeoutId = null;
  var content = document.regularization.reg.value;
  var txt = document.regularization.reg;
  var pos = txt.selectionStart;

  token = findWord(pos, content);

  if(!token)
  {
    alert("Invalid selection");
  }
  else
  {
    document.regularization.reg_to.value = token;
    reg_toBox = token;
  }
}

function addRule()
{
  var reg_word = reg_thisBox;
  var reg_to = reg_toBox;
  var reg_thisWhole = document.regularization.reg_this.value;
  var reg_toWhole = document.regularization.reg_to.value;
  var choice = document.regularization.reg_choices.value;
  var newRule = "";
  var index = "";
  var rulesToAdd = {rules:[]};
  
  if(reg_thisWhole == "" || reg_toWhole == "")
  {
    alert("Invalid Rule");
    return false;
  }
  
  if(reg_toWhole[reg_toWhole.length] == " ")
  {
    reg_toWhole = reg_toWhole.substring(0, reg_toWhole.length-1);
  }

  if (reg_word != "" && reg_to != "")
  {
    if(choice == "this_word")
    {
      for (var i in distinct.witnesses)
      {
        if(reg_word == distinct.witnesses[i].token)
        {
           index = i;
        }
      }
      
      // get rule for each of the witnesses with this token
      for(var i in distinct.witnesses[index].id)
      {
        var id = getId(distinct.witnesses[index].id[i]);
        //alert(id);
        newRule = createRule(choice, reg_thisWhole, reg_toWhole, reg_word, id, index);
        
        var add = true;
        for(var i in rulesToAdd.rules)
        {
          if(rulesToAdd.rules[i].scope == newRule.scope && rulesToAdd.rules[i].action == newRule.action && 
              rulesToAdd.rules[i].token == newRule.token)
          {
            add = false;
          }
        }
        
        if(add)
        {
          rulesToAdd.rules.push(newRule);
        }
      }
      
      for(var i in rulesToAdd.rules)
      {
        addRuleList(rulesToAdd.rules[i]);
      }
    }
    else
    {
      newRule = createRule(choice, reg_thisWhole, reg_toWhole, reg_word, "", "");
      addRuleList(newRule);
    }
      
  }

  contextStruct = { witnesses: [] };

  document.regularization.reg_this.value = "";
  //document.regularization.reg_to.value = "";
  document.regularization.reg_to.value = reg_toWhole;
  
  if(regOn)
  {
    if(choice != "this_word")
    {
      insertRegTable(choice, reg_thisWhole, reg_toWhole);
    }
    else
    {
      action = newRule.action;
      reg_this = action.split(',')[0];
      reg_this = reg_this.substring(11,reg_this.length);
      reg_to = action.split(', ')[1];
      reg_to = reg_to.substring(0, reg_to.length-1);
      insertRegTable(choice, reg_this, reg_to);
    }
  }
  
  //console.log(newRules);
  
  changeRegularizeLabel(choice, reg_thisWhole, reg_toWhole);
}

function addRuleList(newRule)
{ 
  console.log(newRule);
  sendRule(newRule);
  
  if(isCustomRules)
  {
    customRules.rules.push(newRule);
    allRules.rules.push(newRule);
    newRules.rules.push(newRule);
    regularize(customRules);
  }
  else if(regOn && !isCustomRules)
  {
    allRules.rules.push(newRule);
    var regRules = allRules;
    //CHANGED: check works!
    newRules.rules.push(newRule);
    regularize(regRules);
  }
  else
  {
    newRules.rules.push(newRule);
    regularize(newRules);
  }

}

/*
 * id: id of the witness getting context for
 * index: index in the distinct.witnesses list (for token)
 */
function getContext(id, index)
{ 
  //alert("getContext");
  
  //console.log(contextStruct);
  
  var needMoreContext = false;
  var context = "";
  var contextIndex;
  var origContext = "";
  
  // find the context that relate to the id
  for(var i in contextStruct.witnesses)
  {
    if(contextStruct.witnesses[i].id == id)
    {
      context = contextStruct.witnesses[i].context;
      origContext = context;
      context = context.split(/\W/);
      context = context.join(' ');
      contextIndex = i;
    }
  }
  var re = new RegExp(context, 'g');
  //alert(re);
  
  // find if the context matches any witnesses
  // if it matches any witnesses that are not to be 
  // regularize --> needMoreContext
  // if there are more than one match in a witness to 
  // be regularized --> needMoreContext
  for(var i in allWitnesses.witnesses)
  {
    var witness = allWitnesses.witnesses[i].content.split(/\W/).join(' ');
    var result = witness.match(re);
    var isId = false;
    
    if(result)
    {
      for(var j in distinct.witnesses[index].id)
      {
        dWid = getId(distinct.witnesses[index].id[j]);
        if(dWid == allWitnesses.witnesses[i].id)
        {
          isId = true;
          if(result.length > 1)
          {
            needMoreContext = true;
            //alert(allWitnesses.witnesses[i].id + ": found token match");
          }
        }
      }
      
      if(!isId)
      {
        needMoreContext = true;
        //alert(allWitnesses.witnesses[i].id + ": found witness match");
      }
    }
  }
  
  if(needMoreContext)
  {
    returnContext = getMoreContext(id, index, contextIndex);
    if(returnContext)
    {
      return context = getContext(id, index);
    }
    else
    {
      return origContext;
    }
    //alert("getMoreContext()");
    //return context; // get rid of
  }
  else
  {
    //alert("noMoreContextNeeded");
    return origContext;
  }
  
}

/*
 * id: id of the witness getting context for
 * index: index in the distinct.witnesses list (for token)
 * witnessIndex: index into the contextStruct
 */
function getMoreContext(id, index, witnessIndex)
{
  //alert("getMoreContext");
  
  var tokenWitnessIndex;
  for (var i in allWitnesses.witnesses)
  {
    if(allWitnesses.witnesses[i].id == id)
    {
      tokenWitnessIndex = i;
    }
  }

  if(contextStruct.witnesses[witnessIndex].startPos == 1 && contextStruct.witnesses[witnessIndex].maxPos == totalPos)
  {
    // total context
    return false;
  }
  else if (contextStruct.witnesses[witnessIndex].startPos == 1 && contextStruct.witnesses[witnessIndex].endPos != totalPos)
  {
    contextStruct.witnesses[witnessIndex].endPos++;
    if(allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].endPos] != null)
    {
      contextStruct.witnesses[witnessIndex].context += " " + allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].endPos].t;
    }
    contextStruct.witnesses[witnessIndex].switchDirections = false;
  }
  else if (contextStruct.witnesses[witnessIndex].endPos == totalPos && contextStruct.witnesses[witnessIndex].startPos != 1)
  {
    contextStruct.witnesses[witnessIndex].startPos--;
    if(allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].startPos] != null)
    {
      contextStruct.witnesses[witnessIndex].context = allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].startPos].t + " " + contextStruct.witnesses[witnessIndex].context;
    }
    contextStruct.witnesses[witnessIndex].switchDirections = false;
  }
  else if (contextStruct.witnesses[witnessIndex].goForward == true && contextStruct.witnesses[witnessIndex].endPos != totalPos)
  {
    contextStruct.witnesses[witnessIndex].goForward = false;
    contextStruct.witnesses[witnessIndex].endPos++;
    if(allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].endPos] != null)
    {
      contextStruct.witnesses[witnessIndex].context += " " + allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].endPos].t;
    }
  }
  else if (contextStruct.witnesses[witnessIndex].goForward == false && contextStruct.witnesses[witnessIndex].startPos != 1)
  {
    contextStruct.witnesses[witnessIndex].goForward = true;
    contextStruct.witnesses[witnessIndex].startPos--;
    if(allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].startPos] != null)
    {
      contextStruct.witnesses[witnessIndex].context = allTokens.alignment[tokenWitnessIndex].tokens[contextStruct.witnesses[witnessIndex].startPos].t + " " + contextStruct.witnesses[witnessIndex].context;
    }
  }

  //console.log(contextStruct);

  return true;
}

function sendRule(newRule)
{
  var sendRules = {rules: []};
  sendRules.rules.push(newRule);
  sendRules.urn = urn;
  sendRules.userName = userName;
  sendRules.ruleSetName = ruleSetName;
  
    $.post("http://127.0.0.1:8000/regularization/postNewRule/",
       JSON.stringify(sendRules), function(data){
       //alert("success");
     })
   .error(function () {alert("error: saveRules");})
  
  //alert("sendRule");
//  var sendRules = {rules:[]};
//  sendRules.rules.push(newRule);
//
//  $.post("http://127.0.0.1:8000/regularization/interface/saveRules/",
//       JSON.stringify(sendRules), function(data){
//       //alert("success");
//     })
//   .error(function () {alert("error: saveRules");});

}

function changeRegularizeLabel(choice, reg_thisWhole, reg_toWhole)
{

  //alert("changeRegularizeLabel");
  
  changeLabelTimer = null;
  
  var scope = "";
  if(choice == "all_places")
  {
    scope = "all places in all witnesses.";
  }
  else if (choice == "this_block")
  {
    scope = "all witnesses in this block.";
  }
  else
  {
    scope = "all witnesses for this word.";
  }
  
  var content = "REGULARIZED:: \"" + reg_thisWhole + "\" to \"" + reg_toWhole + "\" in " + scope + "</br>";
  document.getElementById('regularize_label').innerHTML = content;
  
  //alert(content);
  
  if (changeLabelTimer == null || !changeLabelTimer)
  {
    changeLabelTimer = setTimeout(function() {document.getElementById('regularize_label').innerHTML = "Double click on the word you want regularized, single click or type in the word you want it regularized to.  Select combination of Witnesses and Place.  Click OK when finished.";}, 5000);
  }
  
}

function regularize_onoff()
{
  
  if (regOn == false)
  {
    
     document.regularization.originals.style.visibility = "visible";
     document.getElementById("showOriginals").style.visibility = "visible";
  
     regOn = true;
     document.getElementById('reg_on').innerHTML = "Regularization is on! Click on a witness for a regularized word to see more detail.";
     document.getElementById('reg_button').value = "Reg. Off";
     
     if(isRecollate)
     {
       recollate();
       isRecollate = false;
     }

     //getRules();
     loadRegTable();
  
     var regRules = { rules: []};
      if(isCustomRules)
      {
          regRules = customRules;
          ///alert("isCustom: getRules");
      }
      else
      {
          regRules = allRules;
      }

      regularize(regRules);
  }
  else
  {
     document.regularization.originals.style.visibility = "hidden";
     document.getElementById("showOriginals").style.visibility = "hidden";
    
     regOn = false;
     string = "Regularization is off! (Showing originals)";
     document.getElementById('reg_on').innerHTML = string;
     document.getElementById('reg_button').value = "Reg. On";
     
     document.information.style.visibility = "hidden";
     document.edit_reg.style.visibility = "hidden";
     
     allTokens = origTokens;
     
     if(isCustomRules)
     {
       regularize(customRules);
     }
     else
     {
       newRules = { rules: [] };
       regularize(newRules);
     }
  }
}

function regularize(regRules)
{
  
  distinct = {witnesses:[]};

  var position = currentPosition;

  for (var i in allTokens.alignment)
  {
    var regToken = false;
    var origToken = "";
    var added = false;
    var token = "";

    // get token from json
    if(allTokens.alignment[i].tokens[position] == null)
    {
       origToken = "null";
    }
    else
    {
      origToken = allTokens.alignment[i].tokens[position].t;
    }

    // regularize token
    var token = getToken(regRules, i, position);
    

    // determine what the original token is, if it is regularized
    if(origToken != token)
    {
      regToken=true;
    }
    
    if(allTokens.alignment[i].tokens[position] != null)
    {
      if(allTokens.alignment[i].tokens[position].origToken != "" && allTokens.alignment[i].tokens[position].origToken != undefined)
      {
        regToken = true;
        origToken = allTokens.alignment[i].tokens[position].origToken;
      }
    }
    
    // search if token is already in the array
    // if is ... add after
    for(var j in distinct.witnesses)
    {
      var distinctToken = distinct.witnesses[j].token;
      
      if(token == distinctToken && !added)
      {
        for( var k in distinct.witnesses[j].originals)
        {
          //console.log(distinct);
          if(origToken == distinct.witnesses[j].originals[k].origToken && !added)
          {
            distinct.witnesses[j].originals[k].id.push(allTokens.alignment[i].witness);
            added = true;
          }
        }
        if(!added)
        {
          distinct.witnesses[j].originals.push({
            "origToken": origToken,
            "id": []
          });
          
          var index = distinct.witnesses[j].originals.length-1;
          distinct.witnesses[j].originals[index].id.push(allTokens.alignment[i].witness);
          added = true;
        }
      }
    }
    
    // add token to array because it is the first one
    if(i==0)
    {
      distinct.witnesses.push({
        "token": token,
        "originals": []
      });
      
      distinct.witnesses[i].originals.push({
        "origToken": origToken,
        "id" : []
      });
      
      distinct.witnesses[i].originals[i].id.push(allTokens.alignment[i].witness);
      added = true;
    }
    // not already in array ... add token and id to it
    else if (!added)
    {
      distinct.witnesses.push({
        "token": token,
        "originals": []
      });
      
      for(var j in distinct.witnesses)
      {
        if(distinct.witnesses[j].token == token && !added)
        {
          distinct.witnesses[j].originals.push({
            "origToken": origToken,
            "id" : []
          });
          
          var index = distinct.witnesses[j].originals.length-1;
          distinct.witnesses[j].originals[index].id.push(allTokens.alignment[i].witness);
        }
      }
    }
  }
  
  // create the content for the collation area text box
  var content = "";
  for (var i in distinct.witnesses)
  {
    content += distinct.witnesses[i].token;
    
    for(var j in distinct.witnesses[i].originals)
    {
      if(distinct.witnesses[i].originals[j].origToken != distinct.witnesses[i].token && isOriginals)
      {
        for(var k in distinct.witnesses[i].originals[j].id)
        {
          content += " " + distinct.witnesses[i].originals[j].id[k];
        }

        content += "(" + distinct.witnesses[i].originals[j].origToken + "), ";
      }
      else
      {
        for(var k in distinct.witnesses[i].originals[j].id)
        {
          content += " " + distinct.witnesses[i].originals[j].id[k];
        }
      }
    }
    
    content += " /// "; 
  }
  
  automateReg(document.getElementById("automate"));

  document.regularization.reg.value = content;
  
}

//http://www.openjs.com/scripts/events/keyboard_shortcuts/
shortcut = {
	'all_shortcuts':{},//All the shortcuts are stored in this array
	'add': function(shortcut_combination,callback,opt) {
		//Provide a set of default options
		var default_options = {
			'type':'keydown',
			'propagate':false,
			'disable_in_input':false,
			'target':document,
			'keycode':false
		}
		if(!opt) opt = default_options;
		else {
			for(var dfo in default_options) {
				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
			}
		}

		var ele = opt.target;
		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
		var ths = this;
		shortcut_combination = shortcut_combination.toLowerCase();

		//The function to be called at keypress
		var func = function(e) {
			e = e || window.event;
			
			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
				var element;
				if(e.target) element=e.target;
				else if(e.srcElement) element=e.srcElement;
				if(element.nodeType==3) element=element.parentNode;

				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
			}
	
			//Find Which key is pressed
			if (e.keyCode) code = e.keyCode;
			else if (e.which) code = e.which;
			var character = String.fromCharCode(code).toLowerCase();
			
			if(code == 188) character=","; //If the user presses , when the type is onkeydown
			if(code == 190) character="."; //If the user presses , when the type is onkeydown

			var keys = shortcut_combination.split("+");
			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
			var kp = 0;
			
			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
			var shift_nums = {
				"`":"~",
				"1":"!",
				"2":"@",
				"3":"#",
				"4":"$",
				"5":"%",
				"6":"^",
				"7":"&",
				"8":"*",
				"9":"(",
				"0":")",
				"-":"_",
				"=":"+",
				";":":",
				"'":"\"",
				",":"<",
				".":">",
				"/":"?",
				"\\":"|"
			}
			//Special Keys - and their codes
			var special_keys = {
				'esc':27,
				'escape':27,
				'tab':9,
				'space':32,
				'return':13,
				'enter':13,
				'backspace':8,
	
				'scrolllock':145,
				'scroll_lock':145,
				'scroll':145,
				'capslock':20,
				'caps_lock':20,
				'caps':20,
				'numlock':144,
				'num_lock':144,
				'num':144,
				
				'pause':19,
				'break':19,
				
				'insert':45,
				'home':36,
				'delete':46,
				'end':35,
				
				'pageup':33,
				'page_up':33,
				'pu':33,
	
				'pagedown':34,
				'page_down':34,
				'pd':34,
	
				'left':37,
				'up':38,
				'right':39,
				'down':40,
	
				'f1':112,
				'f2':113,
				'f3':114,
				'f4':115,
				'f5':116,
				'f6':117,
				'f7':118,
				'f8':119,
				'f9':120,
				'f10':121,
				'f11':122,
				'f12':123
			}
	
			var modifiers = { 
				shift: { wanted:false, pressed:false},
				ctrl : { wanted:false, pressed:false},
				alt  : { wanted:false, pressed:false},
				meta : { wanted:false, pressed:false}	//Meta is Mac specific
			};
                        
			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
			if(e.shiftKey)	modifiers.shift.pressed = true;
			if(e.altKey)	modifiers.alt.pressed = true;
			if(e.metaKey)   modifiers.meta.pressed = true;
                        
			for(var i=0; k=keys[i],i<keys.length; i++) {
				//Modifiers
				if(k == 'ctrl' || k == 'control') {
					kp++;
					modifiers.ctrl.wanted = true;

				} else if(k == 'shift') {
					kp++;
					modifiers.shift.wanted = true;

				} else if(k == 'alt') {
					kp++;
					modifiers.alt.wanted = true;
				} else if(k == 'meta') {
					kp++;
					modifiers.meta.wanted = true;
				} else if(k.length > 1) { //If it is a special key
					if(special_keys[k] == code) kp++;
					
				} else if(opt['keycode']) {
					if(opt['keycode'] == code) kp++;

				} else { //The special keys did not match
					if(character == k) kp++;
					else {
						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
							character = shift_nums[character]; 
							if(character == k) kp++;
						}
					}
				}
			}
			
			if(kp == keys.length && 
						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
						modifiers.shift.pressed == modifiers.shift.wanted &&
						modifiers.alt.pressed == modifiers.alt.wanted &&
						modifiers.meta.pressed == modifiers.meta.wanted) {
				callback(e);
	
				if(!opt['propagate']) { //Stop the event
					//e.cancelBubble is supported by IE - this will kill the bubbling process.
					e.cancelBubble = true;
					e.returnValue = false;
	
					//e.stopPropagation works in Firefox.
					if (e.stopPropagation) {
						e.stopPropagation();
						e.preventDefault();
					}
					return false;
				}
			}
		}
		this.all_shortcuts[shortcut_combination] = {
			'callback':func, 
			'target':ele, 
			'event': opt['type']
		};
		//Attach the function with the event
		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
		else ele['on'+opt['type']] = func;
	},

//Remove the shortcut - just specify the shortcut and I will remove the binding
	'remove':function(shortcut_combination) {
		shortcut_combination = shortcut_combination.toLowerCase();
		var binding = this.all_shortcuts[shortcut_combination];
		delete(this.all_shortcuts[shortcut_combination])
		if(!binding) return;
		var type = binding['event'];
		var ele = binding['target'];
		var callback = binding['callback'];

		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
		else ele['on'+type] = false;
	}
}

function findNextVariant()
{

  //alert("Tab");

  var reg_to = document.regularization.reg_to.value;

  var position = currentPosition;
  var regRules = "";

  if(isCustomRules)
  {
    regRules = customRules;
  }
  else
  {
    regRules = newRules;

    if(regOn)
    {
      for(var i in allRules.rules)
      {
        regRules.rules.push(allRules.rules[i]);
      }
    }
  }

  if(reg_to == "")
  {
    alert("Please select a token");
  }
  else
  {
     //alert("tokenSelected");
     reg_to = reg_to.split(" ", 1);
     var found = false;
     var foundVariant = false;
     var variant = "";
     for (var i in allTokens.alignment)
     {
       var token = getToken(regRules, i, position);

       if (token == reg_to && !found)
       {
         //alert(token);
         found = true;
       }
       else if (found && reg_to != token && !foundVariant)
       {
           foundVariant = true;
           variant = token;
           reg_thisBox = token;
           //alert(variant);
       }
     }
     if(foundVariant)
     {
       document.regularization.reg_this.value = "";
       document.regularization.reg_this.value = variant;
     }
     else
     {
       alert("Error: Cannot get next variant.");
     } 
   }
}

function addTokenTo()
{
    // if more than one winess, check to see if words are different
    // if words are different -> cannot add next word
    // else add next word to reg_this
    // if reg_on see if rules apply to next word!

  var reg_this = document.regularization.reg_to.value;
  var position = currentPosition;
  var newToken = "";
  var regRules = "";

  if(isCustomRules)
  {
    regRules = customRules;
  }
  else
  {
    regRules = newRules;

    if(regOn)
    {
      for(var i in allRules.rules)
      {
        regRules.rules.push(allRules.rules[i]);
      }
    }
  }
  
  var reg_thisArray = reg_this.split(" ");
  var newPosition = currentPosition-1;
  newPosition += reg_thisArray.length;

  if(reg_this == "")
  {
    alert("Please select a token");
  }
  else if(newPosition >= totalPos)
  {
    alert("Cannot add next token: There are no more tokens in entity!");
  }
  else
  {
     position--;
     for(var i in reg_thisArray)
     {
       reg_this = reg_thisArray[i];
       position++;
     }
  
     var add = true;
     var found = false;

     for (var i in allTokens.alignment)
     {
       //alert(allTokens.alignment[i].witness);
       var token = getToken(regRules, i, position);
        
        if(token == reg_this)
        {
         var newPosition = position + 1;
         var rToken = getToken(regRules, i, newPosition);

          if(!found)
          {
           	found = true;
           	newToken = rToken;
           	//alert(newToken);
          }
          else if(found && rToken != newToken)
          {
            //alert("here");
            add = false;
          }
         }
    }

     if(add)
     {
       document.regularization.reg_to.value += " " + newToken;
     }
     else
     {
       alert("Error: Cannot get next token.  Not all next tokens match.");
     } 
  }

}

function addTokenThis()
{
    // if more than one winess, check to see if words are different
    // if words are different -> cannot add next word
    // else add next word to reg_this
    // if reg_on see if rules apply to next word!

  var reg_this = document.regularization.reg_this.value;
  var position = currentPosition;
  var newToken = "";
  var regRules = "";

  if(isCustomRules)
  {
    regRules = customRules;
  }
  else
  {
    regRules = newRules;

    if(regOn)
    {
      for(var i in allRules.rules)
      {
        regRules.rules.push(allRules.rules[i]);
      }
    }
  }
  
  var reg_thisArray = reg_this.split(" ");
  var newPosition = currentPosition-1;
  newPosition += reg_thisArray.length;

  if(reg_this == "")
  {
    alert("Please select a token");
  }
  else if(newPosition >= totalPos)
  {
    alert("Cannot add next token: There are no more tokens in entity!");
  }
  else
  {
     position--;
     for(var i in reg_thisArray)
     {
       reg_this = reg_thisArray[i];
       position++;
     }
  
     var add = true;
     var found = false;

     for (var i in allTokens.alignment)
     {
       //alert(allTokens.alignment[i].witness);
       var token = getToken(regRules, i, position);
        
        
        if(token == reg_this)
        {
          var newPosition = position + 1;
          var rToken = getToken(regRules, i, newPosition);

          if(!found)
          {
           	found = true;
           	newToken = rToken;
           	//alert(newToken);
          }
          else if(found && rToken != newToken)
          {
            //alert("here");
            add = false;
          }
         }
    }

     if(add)
     {
       document.regularization.reg_this.value += " " + newToken;
     }
     else
     {
       alert("Error: Cannot get next token.  Not all next tokens match.");
     } 
  }
}

function buildWitnesses()
{
  //alert("buildWitnesses");
  newWitnesses = { witnesses: [] };
  var regRules = allRules;
  isBuildWitnesses = true;
  allTokens = origTokens;

//  $.ajax({
//    url: "http://127.0.0.1:8000/regularization/interface/getRules/",
//    dataType: 'json',
//    async: false,
//    success: function(jdata){
//
//    regRules = jdata;
//    
//    if(isCustomRules)
//    {
//      regRules = customRules;
//      $.ajax({
//    	url: "http://127.0.0.1:8000/regularization/interface/getBaseTokens/",
//    	dataType: 'json',
//    	async: false,
//    	success: function(jdata){
//    		origTokens = jdata;
//    		allTokens = origTokens;
//    	
//    	}});
//      
//    }
//
//  }});

  for (var i in allTokens.alignment)
  {
    var content = "";
    for (var j in allTokens.alignment[i].tokens)
    {
      var token = getToken(regRules, i, j);
      if(token != "null")
      {
        content += token + " ";
      }
    }

    content = content.substring(0, content.length-1);
    newWitnesses.witnesses.push ({
      "id": allTokens.alignment[i].witness,
      "content": content
    });
  }
  
  isBuildWitnesses=false;

  return newWitnesses;
}

function seeWitnesses()
{

  newWitnesses = buildWitnesses();
  newWitnesses.userName = userName;
  newWitnesses.urn = urn;
  newWitnesses.ruleSetName = ruleSetName;
  newWitnesses.witnessesTokens = witnessDataTokens;
  newWitnesses.witnessesLines = witnessDataLines;
  newWitnesses.ruleSet = ruleSet;
  newWitnesses.position = currentPosition;

  $.ajax({
    url: "http://127.0.0.1:8000/regularization/postEntireReg/",
    dataType: 'json',
    type: 'POST',
    async: false,
    data: JSON.stringify(newWitnesses),
    success: function(data){
    }});
  
  window.location.href = "http://127.0.0.1:8000/regularization/viewEntireReg/";
  
}

function recollate()
{
  //alert("recollate");
  
  isRecollate = false;
  var newWitnesses = buildWitnesses();
  newWitnesses = JSON.stringify(newWitnesses);
  
  console.log(allTokens);
  console.log(newWitnesses);
  
  $.ajax({
    url: "http://127.0.0.1:8000/regularization/interface/recollate/",
    dataType: 'json',
    type: 'post',
    async: false,
    data: newWitnesses,
    success: function(data){
 
      for(var i in data.alignment)
      {
        for(var j in data.alignment[i].tokens)
        {
            for(var k in allTokens.alignment[i].tokens)
            {
              if(allTokens.alignment[i].tokens[k] != null && data.alignment[i].tokens[j] != null)
              {
                if(allTokens.alignment[i].tokens[k].t == data.alignment[i].tokens[j].t)
                {
                  data.alignment[i].tokens[j].origToken = allTokens.alignment[i].tokens[k].origToken;
                }
              }
            }
        }
      }
      
      allTokens = data;
      
      totalPos = -1;
      // find how many positions are in tokens
      for (var i in allTokens.alignment[0].tokens)
      {
        totalPos++;
      }
      
      $.getJSON("http://127.0.0.1:8000/regularization/interface/getBaseTokens/",
function(jdata) {
        origTokens = jdata;

      })
      .error(function () {alert("error: getBaseTokens2");});
 }});
}

function checkSpaces(reg_word)
{
  
  var position = 0;
  var i = -1;
  var indices = [];
  
  while (position != -1)
  {
    position = reg_word.indexOf(" ", i + 1);
    if(position != -1)
    {
      indices.push(position);
    }
    i = position;
  }
  
  if(indices == [])
  {
    return false;
  }
  else
  {
    return indices;
  }
}

function getToken(regRules, witnessId, position)
{

   var token = "";
   var collate = false;
   var origToken = "";
   //var wholeToToken = "";
   //var nonRegToken = "";
  
   if(allTokens.alignment[witnessId].tokens[position] == null)
   {
     token = "null";
   }
   else
   {
     token = allTokens.alignment[witnessId].tokens[position].t;
     //nonRegToken = token;
   }
   
   //console.log(regRules);

   for (var k in regRules.rules)
   {
     if (token == regRules.rules[k].token)
     {
        //alert(token);
        action = regRules.rules[k].action;
        reg_this = action.split(',')[0];
        reg_this = reg_this.substring(11,reg_this.length);
        reg_to = action.split(', ')[1];
        reg_to = reg_to.substring(0, reg_to.length-1);
        wholeToToken = reg_to;
        choice = regRules.rules[k].scope;
        
        if(choice == "this_word")
        {
          var found = false;
          var reg_thisIndex = -1;
          var reg_thisArray = reg_this.split(" ");
          for(var m in reg_thisArray)
          {
            if(reg_thisArray[m] == token && !found)
            {
              found = true;
              reg_thisIndex = m;
              
            }
          }
          if(found)
          {
            reg_thisArray.splice(0, reg_thisIndex);
          }
          origToken = reg_thisArray[0];
          reg_thisArray = reg_thisArray.join(" ");
          //alert(reg_thisArray);
          
          found = false;
          var reg_thisArray2 = reg_this.split(" ");
          var reg_toArray = reg_to.split(" ");
          var reg_toIndex = -1;
          
          for(var m in reg_toArray)
          {
            if(reg_toArray[m] != reg_thisArray2[m] && !found)
            {
              found = true;
              reg_toIndex = m;
            }
          }
          if(found)
          {
            reg_toArray.splice(0, reg_toIndex);
          }
          reg_toArray = reg_toArray.join(" ");
          //alert(reg_toArray);
          
          reg_this = reg_thisArray;
          reg_to = reg_toArray;
          
        }
        
        var spacesThis = checkSpaces(reg_this);
        var spacesTo = checkSpaces(reg_to);
        
        if(spacesThis != false)
        {
            //Check if next word(s) match
            // if match -> recollate

            var content = token;

            for (var i in spacesThis)
            {
              position++;
              if(allTokens.alignment[witnessId].tokens[position] == null)
              {
                newToken = "null";
              }
              else
              {
                newToken = allTokens.alignment[witnessId].tokens[position].t;
              }
              content += " " + newToken;
            }

            if(content == reg_this)
            {
              position = currentPosition;
              if(origToken == "")
              {
                origToken = reg_this;
              }
              allTokens.alignment[witnessId].tokens[position].t = reg_to;
              allTokens.alignment[witnessId].tokens[currentPosition].origToken = origToken;
              allTokens.alignment[witnessId].tokens[currentPosition].reg_to = reg_to;

              //console.log(allTokens);
              position++;
              for(var k in spacesThis)
              { 
                allTokens.alignment[witnessId].tokens.splice(position, 1);
              }
              collate = true;
            }
		  
        }
        else
        {
          token = reg_to;
//          if(isRecollate)
//          {
//            token = nonRegToken;
//          }
        }
        
        if(spacesTo != false && !isBuildWitnesses)
        {
            //Check if next word(s) match
            // if match -> recollate

            var content = reg_to;
            //alert("spacesTo");

            content = content.split(' ').join('');

            //alert(content + " " + reg_this + " " + reg_to);

            if(content == reg_this)
            {
              var insertTokens = reg_to.split(' ');
              var position = currentPosition;
              for(var k in insertTokens)
              {
                if(k == 0)
                {
                  if(origToken == "")
                  {
                    origToken = reg_this;
                  }
                  allTokens.alignment[witnessId].tokens[position].t = insertTokens[k];
                  allTokens.alignment[witnessId].tokens[position].origToken = origToken;
                  allTokens.alignment[witnessId].tokens[position].reg_to = reg_to;
                }
                else
                {
                  if(origToken == "")
                  {
                    origToken = reg_this;
                  }
                  var insertTok = { "t" : insertTokens[k], "n" : insertTokens[k], "origToken" : origToken, "reg_to" : reg_to};
                  allTokens.alignment[witnessId].tokens.splice(position,0,insertTok);
                }
                position++;
              }

              //console.log(allTokens);
              reg_to = reg_to.split(' ')[0];
              //alert("reg_to: " + reg_to);
              collate = true;
              token = reg_to;

            }
        }
        else if(spacesTo != false && isBuildWitnesses)
        {
          token = wholeToToken;
          //alert(allTokens.alignment[witnessId].witness + " " + token);
        }
        else
        {
          reg_to = reg_to.split(' ')[0];
          token = reg_to;
        }
      }
    }
    
    if(collate)
    {
      collate = false;
      if(!isBuildWitnesses)
      {
      	//recollate();
      	isRecollate = false;
        reg_to = reg_to.split(' ')[0];
      	token = reg_to;
      }
    }
    
    return token;
}

function informationWindow(witnessId)
{
  //alert("informationWindow");
  var regInfo = { data: [] };
  var context = "";
  var index = "";
  var position = currentPosition;
  var regRules = "";
  var token = "";
  
  witnessId = witnessId.split('(')[0];
  
  for (var i in allWitnesses.witnesses)
  {
    if(witnessId == allWitnesses.witnesses[i].id)
    {
      context = allWitnesses.witnesses[i].content;
      index = i;
    }
  }
  
  if(isCustomRules)
  {
    regRules = customRules;
  }
  else
  {
    regRules = allRules;
  }
  
  var reg_this = "";
  var reg_to = "";
  var choice = "";
  
  for(var i in regRules.rules)
  {
    var action = regRules.rules[i].action;
    
    if(allTokens.alignment[index].tokens != null && allTokens.alignment[index].tokens[currentPosition] != null)
    {
      if(allTokens.alignment[index].tokens[currentPosition].origToken != null && allTokens.alignment[index].tokens[currentPosition].origToken != "")
      {
        if(allTokens.alignment[index].tokens[currentPosition].origToken == regRules.rules[i].token)
        {
          reg_this = regRules.rules[i].token;
          reg_to = action.split(', ')[1];
          reg_to = reg_to.substring(0, reg_to.length-1);
          choice = regRules.rules[i].scope;
        }
      }
      else 
      {
        if (allTokens.alignment[index].tokens[currentPosition] != null)
        {
          token = allTokens.alignment[index].tokens[currentPosition].t;
        }
        else
        {
          token = "null";
        }

        if(token == regRules.rules[i].token)
        {
          reg_this = regRules.rules[i].token;
          reg_to = action.split(', ')[1];
          reg_to = reg_to.substring(0, reg_to.length-1);
          choice = regRules.rules[i].scope;
        }
      }
    }
    else
    {
      token = "null";
    }
  }
  
  if(choice == "all_places")
  {
    choice = "all places in all witnesses";
  }
  else if(choice == "this_block")
  {
    choice = "this entity in all witnesses";
  }
  else if(choice == "this_word")
  {
    choice = "this place in all witnesses";
  }
  
  document.information.style.visibility = "visible";
  document.reg_information.style.visibility ="hidden";
  document.getElementById('witnessId').innerHTML = witnessId;
  document.getElementById('word').innerHTML = position;
  document.getElementById('block').innerHTML = lineNumber; //need to change
  document.getElementById('context').innerHTML = context;
  
  if(reg_this != "" && reg_to != "" && choice != "")
  {
    document.reg_information.style.visibility = "visible";
    document.getElementById('reg_this_info').innerHTML = reg_this;
    document.getElementById('reg_to_info').innerHTML = reg_to;
    document.getElementById('choice').innerHTML = choice;
  }
  
}

function loadRegTable()
{
  var regRules = { rules: [] };
  
  regRules = allRules;

  //delete everything out of reg_table
   var table = document.getElementById('reg_table');
   var rowCount = table.rows.length;
   for(var i =rowCount-1; i>=0; i--)
   {
     table.deleteRow(i);
   }

  var table = document.getElementById('reg_table');

  var rowCount = table.rows.length;
  var row = table.insertRow(rowCount);
  
  var checkCellTitle = row.insertCell(0);
  var scopeCellTitle = row.insertCell(1);
  scopeCellTitle.innerHTML = "Scope";
  var regThisCellTitle = row.insertCell(2);
  regThisCellTitle.innerHTML = "Reg. This";
  var regToCellTitle = row.insertCell(3);
  regToCellTitle.innerHTML = "Reg. To";
  var deleteCellTitle = row.insertCell(4);
  deleteCellTitle.innerHTML = "Delete";
  
  rowCount++; 
  
  for(var i in regRules.rules)
  {
    var scope = regRules.rules[i].scope;
    var reg_this = regRules.rules[i].token;
    var reg_to = "";
    action = regRules.rules[i].action;
    reg_this = action.split(',')[0];
    reg_this = reg_this.substring(11,reg_this.length);
    reg_to = action.split(', ')[1];
    reg_to = reg_to.substring(0, reg_to.length-1);
    
    insertRegTable(scope, reg_this, reg_to);
  	
  	rowCount++;
  }
  
  document.edit_reg.style.visibility = "visible";
}

function insertRegTable(scope, reg_this, reg_to)
{
    if(reg_this == null)
    {
      reg_this = "null";
    }
    
    if(reg_to == null)
    {
      reg_to = "null";
    }
    
    var found = true;
    if(isCustomRules)
    {
      found = false;
      //alert("isCustom: insertRegTable"); 
      
      for(var i in customRules.rules)
      {
        var customScope = customRules.rules[i].scope;
      	var action = customRules.rules[i].action;
        var reg_thisRule = action.split(',')[0];
        reg_thisRule = reg_thisRule.substring(11,reg_thisRule.length);
        var reg_toRule = action.split(', ')[1];
        reg_toRule = reg_toRule.substring(0, reg_toRule.length-1);
        var scopeRule = customRules.rules[i].scope;
	  	
	  	//alert(customScope + " " + scope + " " + reg_thisRule + " " + reg_this + " "+ reg_toRule + " " + reg_to);
        //TODO: add more when completed rules
        if(customScope == scope && reg_this == reg_thisRule && reg_to == reg_toRule)
        {
          found = true;
        }
      }
    }
    
    var table = document.getElementById('reg_table');

    var rowCount = table.rows.length;
  	var row = table.insertRow(rowCount);
    
    var checkCell = row.insertCell(0);
  	var element1 = document.createElement("input");
  	element1.type = "checkbox";
  	if(found)
  	{
  	  element1.checked = "checked";
  	}
  	checkCell.appendChild(element1);
  	
  	var scopeCell = row.insertCell(1);
  	var element2 = document.createElement("select");
  	var option1 = document.createElement("option");
  	option1.text = "All witnesses, this entity";
  	element2.options.add(option1);
  	var option2 = document.createElement("option");
  	option2.text = "All witnesses, this place";
  	element2.options.add(option2);
  	var option3 = document.createElement("option");
  	option3.text = "All witnesses, all places";
  	element2.options.add(option3);
  	if(scope == "all_places")
  	{
  	  element2.selectedIndex = 2; 
  	}
  	else if (scope == "this_word")
  	{
  	  element2.selectedIndex = 1;
  	}
  	scopeCell.appendChild(element2);
  	
  	var regThisCell = row.insertCell(2);
  	var element3 = document.createElement("input");
  	element3.type = "text";
  	element3.size = "40";
  	//regThisCell.innerHTML = reg_this;
  	element3.value = reg_this;
  	regThisCell.appendChild(element3);
  	
  	var regToCell = row.insertCell(3);
  	var element4 = document.createElement("input");
  	element4.type = "text";
  	element4.size = "40";
  	element4.value = reg_to;
  	regToCell.appendChild(element4);
  	
  	
  	var deleteCell = row.insertCell(4);
  	deleteCell.align = "center";
  	var element5 = document.createElement("input");
  	element5.type = "checkbox";
  	//element5.checked = "checked";
  	deleteCell.appendChild(element5);
  	
  	/*
var deleteRegCell = row.insertCell(4);
  	var element5 = document.createElement("input");
  	element5.type = "button";
  	element5.value = "Delete";
  	deleteRegCell.appendChild(element5);
*/
  
}

function submitCustomReg()
{
  //alert("submitCustomReg");
  isCustomRules = true;  // ??!! <----
  var table = document.getElementById('reg_table');
  var rowCount = table.rows.length;
  
  customRules = { rules: [] };
  //first one is one to delete; second is new reg
  var sendRules = { rules: [] };
  var deleteJSON = { rules: [] };
  
  var regRules = allRules;
  //console.log(regRules);
  
  for(var i=1; i<rowCount; i++)
  {
    var row = table.rows[i];
    var check = row.cells[0].childNodes[0];
    var deleteRule = row.cells[4].childNodes[0];
    var index = i - 1;
    var scope = row.cells[1].childNodes[0].value;
    var reg_this = row.cells[2].childNodes[0].value;
    var reg_to = row.cells[3].childNodes[0].value;

    if(scope == "All witnesses, this block")
    {
      scope = "this_block";
    }
    else if(scope == "All witnesses, this word")
    {
      scope = "this_word";
    }
    else
    {
      scope = "all_places";
    }

    var action = regRules.rules[index].action;
    var reg_thisRule = action.split(',')[0];
    reg_thisRule = reg_thisRule.substring(11,reg_thisRule.length);
    var reg_toRule = action.split(', ')[1];
    reg_toRule = reg_toRule.substring(0, reg_toRule.length-1);
    var scopeRule = regRules.rules[index].scope;
    
    if(deleteRule != null && deleteRule.checked)
    {
      // delete from database
      //var newRule = createRule(scope, reg_this, reg_to, regRules.rules[index].token);
      var newRule = allRules.rules[index];
      deleteJSON.rules.push(newRule);
      check.checked = false;
    }
    
    if(check != null && check.checked)
    {
      //alert(reg_this);

      if(reg_this == reg_thisRule && reg_to == reg_toRule && scope == scopeRule)
      {
        //add to customReg
        customRules.rules.push(regRules.rules[index]);
        //alert("match");
      }
      else
      {
        //delete from database
        // save new rule
        //update rules

        //isCustomRules = true;
        sendRules.rules.push(regRules.rules[index]);

        var newRule = createRule(scope, reg_this, reg_to, regRules.rules[index].token);
        sendRules.rules.push(newRule);
        customRules.rules.push(newRule);

      }
    }
  }
  
   $.ajax({
	    	url: "http://127.0.0.1:8000/regularization/interface/deleteRule/",
	    	dataType: 'json',
	    	type: 'post',
	    	async: false,
	    	data: JSON.stringify(deleteJSON),
	    	success: function(data){
	    	
	    	  alert("success");
	    	
	    	}
	    });
	 
	 $.ajax({
	    	url: "http://127.0.0.1:8000/regularization/interface/changeRule/",
	    	dataType: 'json',
	    	type: 'post',
	    	async: false,
	    	data: JSON.stringify(sendRules),
	    	success: function(data){
	    	
	    	  alert("success");
	    	
	    	}
	    });
            
      
   // get new/all rules and reload reg_table
   $.ajax({
    	url: "http://127.0.0.1:8000/regularization/interface/getBaseTokens/",
    	dataType: 'json',
    	async: false,
    	success: function(jdata){
    		origTokens = jdata;
    		allTokens = origTokens;
    	
    	}});

   getRules();
   
   //console.log(customRules);
   //console.log(allRules);
}

function getId(witnessId)
{
  var re = new RegExp('ORIG', 'g');
  var result = witnessId.match(re);
  
  if(result)
  {
    return witnessId.split('(ORIG:')[0];
  }
  else
  {
    return witnessId;
  }
  
}

  function createRule(scope, reg_this, reg_to, token, id, index)
{
 
  contextStruct = {witnesses:[]};
  var goForward;
  var context = reg_this;
  
  if(currentPosition == totalPos)
  {
    goForward = false;
  }
  else
  {
    goForward = true;
  }
  
  if(scope == "this_word")
  {
      contextStruct.witnesses.push({
        "id": id,
        "token": token,
        "context": reg_this,
        "tokenPos": currentPosition,
        "startPos": currentPosition,
        "endPos": currentPosition,
        "goForward": goForward,
        "switchDirections": true
        
      });
      //alert("before getContext: " + context);
      context = getContext(id, index);
      //alert("after getContext: " + context);
      
      var contextRegTo = context.replace(reg_this, reg_to);
      reg_to = contextRegTo;
      //alert("reg_to: " + reg_to);
  }
  
  var currentDate = new Date();
  var day = currentDate.getDate();
  var month = currentDate.getMonth() + 1;
  var year = currentDate.getFullYear();
  var hours = currentDate.getHours();
  var minutes = currentDate.getMinutes();
  var seconds = currentDate.getSeconds();
  var dateTime = hours + ":" + minutes + ":" + seconds + " " + month + "/" + day + "/" + year
  //alert(dateTime);
  
  var action = "regularize(" + context + ", " + reg_to + ")";
  newRule = {
             "_id" : "",
             "appliesTo" : urn,
             "action" : action,
             "modifications" : [{
               "userId": userName,
               "modification_type": "create",
               "dateTime": dateTime
             }],
             "scope" : scope,
             "token" : token
           };
           
           
  return newRule;

}

function automateReg(checkBox)
{
  
  if(checkBox.checked)
  {
    autoReg = true; 
    
    var maxPosition = 0;
    var maxLength = 0;
    
    for (var i in distinct.witnesses)
    {
      var numberIds = 0;
      for(var j in distinct.witnesses[i].originals)
      {
        for(var k in distinct.witnesses[i].originals[j].id)
        {
          numberIds++;
        }
      }
       
      // nothing should ever be regularized to null
      if(numberIds > maxLength && distinct.witnesses[i].token != "null")
      {
        maxPosition = i;
        maxLength = numberIds;
      }
    }
   
    
    document.regularization.reg_to.value = distinct.witnesses[maxPosition].token;
    
    // null should never be regularized to anything ?!?
    if(distinct.witnesses[maxPosition] == "null")
    {
      maxPosition++;
    }
    
    if(maxPosition != distinct.witnesses.length-1)
    {
      maxPosition++;
      document.regularization.reg_this.value = distinct.witnesses[maxPosition].token;
    }
    else if(maxPosition != 0 && maxPosition == distinct.witnesses.length)
    {
      document.regularization.reg_this.value = distinct.witnesses[0].token;
    }
    
    reg_thisBox = document.regularization.reg_this.value;
    reg_toBox = document.regularization.reg_to.value;
    
  }
  else
  {
    autoReg = false;
    
    document.regularization.reg_this.value = "";
    document.regularization.reg_to.value = "";
  }
}

function backEntity()
{
  if(lineNumber > 0)
  {
    lineNumber--;
  }
  getTokensWitnesses(false);
  //shows all previously collated words and allows user to choose one to go to
}

function forwardEntity()
{
  lineNumber++;
  getTokensWitnesses(true);
}


function showOriginals(checkBox)
{
  //var checkBox = document.getElementById("originals");
  
  if(checkBox.checked)
  {
    isOriginals = true;
    
    if(isCustomRules)
    {
      var regRules = customRules;
    }
    else
    {
      var regRules = allRules;
    }

    for(var i in newRules.rules)
    {
      regRules.rules.push(newRules.rules[i]);
    }
    regularize(regRules);
    
  }
  else
  {
    isOriginals = false; 
    
    if(isCustomRules)
    {
      var regRules = customRules;
    }
    else
    {
      var regRules = allRules;
    }

    for(var i in newRules.rules)
    {
      regRules.rules.push(newRules.rules[i]);
    }
    regularize(regRules);
  }
}

</script>
</head>

<body onload="load()">
  <h1>Collation Interface: for <label for="title_label" id="title_label"></label></h1>
<label for="regularize_label" id="regularize_label">Single click on the word you want regularized, double click or type in the
word you want it regularized to.  Select
combination of Witnesses and Place.  Click OK when
finished.</label>
<br /><br /><label for="reg_on" id="reg_on">Regularization is off! (Showing
originals)
</label>

<table>
<tr>
<td>
<form action="." method="POST" name="regularization">
       <br /><textarea rows="10" cols="75" name="reg" onclick="determineClick()"></textarea>
           
       <br /><label id="reg_this">Regularize This:</label>
           <input type="text" name="reg_this" size="82"/>
       <br /><label id="reg_to">To This:</label>
           <input type="text" name="reg_to" size="92"/>

        <p>Regularize Choices:
       <select name="reg_choices">
	  <option value="this_block">All witnesses, this entity</option>
	  <option value="this_word">All witnesses, this place</option>
	  <option value="all_places">All witnesses, all places</option>
	  <option value="other">Other ...</option>
	</select></p>

	<input name="ok" type="button" value="Add Rule"
	onclick="addRule()">
	<!-- <input name="edit_reg" type="button" value="Edit Reg."> -->
	<input name="reg_on" id="reg_button" type="button" value="Reg. On"
	onclick="regularize_onoff()">
	
	<input name="back" type="button" value="Back Entity" onclick="backEntity()">
        <input name="forward" type="button" value="Forward Entity" onclick="forwardEntity()">
	<input name="previous" type="button" value="Previous Word" onclick="previousToken()">
	<input name="next" type="button" value="Next Word" onclick="nextToken()">
        <br />
	<input name="view" type="button" value="View Entire Reg." onclick="seeWitnesses()">
	<input name="done" type="button" value="DONE">
	<br /> Shortcuts:: <br/>"Alt+Right Arrow": Add next word to Regularize This
	<br /> "Shift+Right Arrow": Add next word to Regularize To
	<br /> "Tab": Find next variant to regularize
        <br /> "Enter": Add rule
	<br /> <input type="checkbox" name="automate" value="automate" id="automate"
	onchange="automateReg(this)"/> Automate regularization selection
        <br /> <input type="checkbox" name="originals" value="originals" onchange="showOriginals(this)"/>
        <label id="showOriginals">Show originals</label>
<!--        <br /> <select name="collation_type">
          <option value="word">Word collation</option>
          <option value="line">Line collation</option>
        </select>
        <input name="see_collation" type="button" value="Go!" onclick="seeCollation()"/>-->
    </form>
</td>
<td valign="top">
<form action="." method="POST" name="information">
<h2>Regularization Information</h2>
Regularization at word <label for="word" id="word"></label> in entity <label for="block" id="block"></label>
in witness <label for="witnessId" id="witnessId"></label>

<br /><br />

Context:<br/>
<label for="context" id="context"></label>

<br /><br />

</form>
<form action="." method="POST" name="reg_information">
Reg. from:<br/>
<label for="reg_this_info" id="reg_this_info"></label>

<br /><br />

Reg. to:<br/>
<label for="reg_to_info" id="reg_to_info"></label>

<br /><br />

This regularization set for <label for="choice" id="choice"></label>
</form>
</td>
</tr>
</table>

<form name="edit_reg">
<h2>Regularizations</h2>

<table id="reg_table" border="1">
	
</table>

<input name="submit" type="button" value="Submit" onclick="submitCustomReg()">

</form>

</body> </html>
